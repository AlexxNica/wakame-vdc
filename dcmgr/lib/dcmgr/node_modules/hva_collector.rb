# -*- coding: utf-8 -*-
require 'isono'
require 'ipaddress'

module Dcmgr
  module NodeModules
    class HvaCollector < Isono::NodeModules::Base
      include Isono::NodeModules

      initialize_hook do
        rpc = RpcChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('hva-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def get_instance(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        ret = inst.to_hash
        ret
      end

      def update_instance(instance_id, data)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?
        if data[:state] == :terminated
          inst.terminated_at = data[:terminated_at]
          # Instance#destroy do not really delete row.
          # just for chain react destroy hooks in the associated models.
          inst.destroy
        else
          inst.set(data).save
        end
        # do not respond model object.
        nil
      end

      def get_netfilter_groups_of_instance(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        inst.netfilter_groups.map { |g| g.to_hash }
      end

      def get_group_instance_ipv4s(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        ipv4s = inst.netfilter_groups.map { |netfilter_group|
          next if netfilter_group.nil?
          netfilter_group.instance_netfilter_groups.map { |instance_netfilter_group|
            next if instance_netfilter_group.nil?
            instance_netfilter_group.instance_dataset.lives.all.map { |instance|
              next if instance.nil?
              instance.ips.map { |ip|
                next if ip.nil?
                ip.map {|i| unless i.is_natted? then i.ipv4 else nil end}.compact
              }
            }
          }
        }.flatten.uniq.compact
        ipv4s
      end

#      def get_instances_of_account_netfilter_group(account_id, netfilter_group_id)
      def get_instances_of_account_netfilter_group(account_id, netfilter_group_name)
        Models::NetfilterGroup.lock!
        ng_map = Models::NetfilterGroup.find(:account_id => account_id, :name => netfilter_group_name)
        raise "UnknownNetfilterGroupID" if ng_map.nil?
        inst_maps = ng_map.instance_netfilter_groups.map { |instance_netfilter_group|
          instance_netfilter_group.instance_dataset.lives.all.map { |inst| inst.to_hash }
        }.flatten.uniq.compact
        inst_maps
      end

      def get_network(network_id)
        Models::Network.lock!
        network = Models::Network[network_id]
        raise "UnknownNetworkID" if network.nil?
        network.to_hash
      end

      #Returns the current iplease for nic with uuid _nic_uuid_
      def get_iplease_for_nic(nic_uuid)
        Models::InstanceNic.lock!
        Models::IpLease.lock!
        
        nic = Models::Taggable.find(nic_uuid)
        Models::IpLease.find(:instance_nic_id => nic[:id])[:ipv4]
      end

      def get_nat_leases(nic_uuid)
        #TODO: get this to work with non canonical uuid
        nic = Models::Taggable.find(nic_uuid)
        
        leases = Models::IpLease.filter({:instance_nic_id => nic[:id]} & ~{:network_id => nic[:network_id]})
        leases.map {|l| l[:ipv4]}
      end

      def is_natted_ip?(ip)
        lease = Models::IpLease.find(:ipv4 => ip)
        
        return false if lease.nil?
            
        #lease.instance_nic.network_id != lease.network_id  
        lease.is_natted?
      end

      def get_networks
        Models::Network.lock!
        networks = Models::Network.all
        networks.map { |network|
          network.to_hash
        }
      end

      def get_dhcp_conf(network_name)
        Models::Network.lock!

        build_network_segment = proc { |network|
          gwaddr = network.ipaddress
          h = {
            :uuid => network.canonical_uuid,
            :ipv4_first => gwaddr.network.first.to_s,
            :ipv4_last  => gwaddr.network.last.to_s,
            :ipv4_gw=>network.ipv4_gw,
            :netmask => gwaddr.network.prefix.to_ip,
            :prefix => network.prefix,
            :dns_server=> network.dns_server,
            :domain_name => network.domain_name,
            :metadata_server => network.metadata_server,
            :mac2addr => [],
            :addr2host=> [],
          }
          
          network.ip_lease_dataset.filter(:type=>Models::IpLease::TYPE_AUTO).each { |ip|
            # ignore IPs unbound to vnic.
            next if ip.instance_nic.nil? || ip.instance_nic.instance.nil?
            
            h[:mac2addr] << {
              :mac_addr => ip.instance_nic.pretty_mac_addr,
              :ipaddr   => ip.ipv4
            }
            h[:addr2host] << {
              :hostname => ip.instance_nic.instance.fqdn_hostname,
              :ipaddr   => ip.ipv4
            }
          }
          
          h
        }

        network_set = nil
        Tags::NetworkPool
        Models::Network
        case network = Models::Taggable.find(network_name)
        when Models::Network
          network_set = [network]
        when Tags::NetworkPool
          network_set = network.mapped_uuids.map {|m| Models::Network[m.uuid] }
        else
          raise "Unknown network name: #{network_name}"
        end
        h = {}
        network_set.each {|n|
          h[n.canonical_uuid] = build_network_segment.call(n)
        }
        h
      end

      def get_instances_of_netfilter_group(netfilter_group_id)
        Models::NetfilterGroup.lock!
        g = Models::NetfilterGroup[netfilter_group_id]
        raise "UnknownNetfilterGroupID" if g.nil?
        inst_maps = g.instance_netfilter_groups.map { |instance_netfilter_group|
          instance_netfilter_group.instance_dataset.lives.all.map { |inst| inst.to_hash }
        }.flatten.uniq.compact
        inst_maps
      end

      def get_alive_instances(node_id)
        Models::HostPool.lock!
        hp = Models::HostPool.find(:node_id => node_id)
        raise "UnknownNodeID", node_id if hp.nil?
        hps = Models::HostPool.where(:account_id => hp.account_id).all
        inst_on_hp = hps.map { |hp|
          inst_on_hp = hp.instances_dataset.lives.all.map { |inst|
            inst_map = inst.to_hash
            # Does the hva have instance?
            next unless inst_map[:host_pool][:node_id] == node_id
            inst_map
          }
        }.flatten.uniq.compact
        inst_on_hp
      end

    end
  end
end
