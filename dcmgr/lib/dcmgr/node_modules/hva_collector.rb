# -*- coding: utf-8 -*-
require 'isono'
require 'ipaddress'

module Dcmgr
  module NodeModules
    class HvaCollector < Isono::NodeModules::Base
      include Isono::NodeModules

      initialize_hook do
        rpc = RpcChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('hva-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def get_instance(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        ret = inst.to_hash
        ret
      end

      def update_instance(instance_id, data)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        inst.set_fields(data, [:state]).save
        # do not respond model object.
        nil
      end

      def get_netfilter_groups_of_instance(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        inst.netfilter_groups.map { |g| g.to_hash }
      end

      def get_group_instance_ipv4s(instance_id)
        Models::Instance.lock!
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        insts = inst.netfilter_group_instances
        ips = insts.map { |instance|
          next if instance.nil?
          instance.ips.map { |ip| ip.ipv4 unless ip.nil? }
        }

        ips.flatten! if ips.size > 0
        ips.compact
      end

      def get_network(network_id)
        Models::Network.lock!
        network = Models::Network[network_id]
        raise "UnknownNetworkID" if network.nil?
        network.to_hash
      end

      def get_networks
        Models::Network.lock!
        networks = Models::Network.all
        networks.map { |network|
          network.to_hash
        }
      end

      def get_dhcp_conf(network_name)
        Models::Network.lock!
        network = Models::Network.find(:name=>network_name)
        raise "Unknown network name: #{network_name}" if network.nil?
        prefix = IPAddress::Prefix32.new(network.prefix)
        h = {
          :ipv4_gw=>network.ipv4_gw,
          :netmask => prefix.to_ip,
          :prefix => network.prefix,
          :dns_server=> network.dns_server,
          :domain_name => network.domain_name,
          :mac2addr => [],
          :addr2host=> [],
        }
        
        network.ip_lease.each { |ip|
          h[:mac2addr] << {
            :mac_addr => ip.instance_nic.pretty_mac_addr,
            :ipaddr   => ip.ipv4
          }
          h[:addr2host] << {
            :hostname => ip.instance_nic.instance.fqdn_hostname,
            :ipaddr   => ip.ipv4
          }
        }

        h
      end

      def get_instances_of_netfilter_group(netfilter_group_id)
        Models::NetfilterGroup.lock!
        g = Models::NetfilterGroup[netfilter_group_id]
        raise "UnknownNetfilterGroupID" if g.nil?
        inst_maps = g.instances.map { |instance| instance.to_hash unless instance.nil? }
        inst_maps.compact
      end

      def get_alive_instances(node_id)
        Models::HostPool.lock!
        hp = Models::HostPool.find(:node_id => node_id)
        raise "UnknownNodeID", node_id if hp.nil?

        inst_on_hp = hp.instances_dataset.lives.all.map { |inst|
          inst.to_hash
        }
        inst_on_hp.uniq! if inst_on_hp.size > 0
        inst_on_hp
      end

    end
  end
end
