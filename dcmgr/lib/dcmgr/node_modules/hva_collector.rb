# -*- coding: utf-8 -*-
require 'isono'
require 'ipaddress'

module Dcmgr
  module NodeModules
    class HvaCollector < Isono::NodeModules::Base
      include Isono::NodeModules
      include Dcmgr::Logger

      initialize_hook do
        rpc = RpcChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('hva-collector', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def get_instance(instance_id)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        ret = inst.to_hash
        ret[:image][:backup_object] = inst.image.backup_object.to_hash
        ret[:image][:backup_object][:backup_storage] = inst.image.backup_object.backup_storage.to_hash
        ret[:image][:backup_object][:uri] = inst.image.backup_object.uri
        ret
      end

      def update_instance(instance_id, data)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?
        if data[:state] == :terminated
          inst.terminated_at = data[:terminated_at]
          # Instance#destroy do not really delete row.
          # just for chain react destroy hooks in the associated models.
          inst.destroy
        else
          inst.set(data).save
        end
        # do not respond model object.
        nil
      end

      def get_image(image_id)
        img = Models::Image[image_id] || raise("Unknown image ID: #{image_id}")
        img.to_hash.merge({:backup_object=>img.backup_object.to_hash})
      end
      
      def update_image(image_id, data)
        img = Models::Image[image_id] || raise("Unknown image ID: #{image_id}")
        if data[:state] == :deleted
          img.deleted_at = data[:deleted_at]
          img.destroy
        else
          img.set(data).save
        end
        # do not respond model object.
        nil
      end
      
      def get_security_groups_of_instance(instance_id)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?

        inst.security_groups.map { |g| g.to_hash }
      end

      #Returns an array containing the ip addresses of all instances in the same security group.
      # _set_ determines which ip addresses are returned. There are 3 possible values
      # :inside is the default value. This returns all inside ip addresses
      # :outside returns all the outside addresses for instances that are natted.
      # :all returns all ip addresses regardless of whether they're natted or not
      def get_group_instance_ipv4s(instance_id,set = :inside)
        inst = Models::Instance[instance_id]
        raise "UnknownInstanceID" if inst.nil?
        raise "Unknown ip set." unless [:inside,:all,:outside].member?(set)

        inst.security_groups.compact.map { |security_group|
          # do not include 'stopped' or 'scheduling' instances as they
          # are not allocated IP address.
          security_group.instances_dataset.runnings.all.compact.map { |instance|
              instance.ips.compact.map { |ip|
                case set
                when :all
                  ip
                when :inside
                  ip.map {|i| unless i.is_natted? then i.ipv4 else nil end}.compact
                when :outside
                  ip.map {|i| if i.is_natted? then i.ipv4 else nil end}.compact
                end
              }
            }
          }.flatten.uniq.compact
      end

      def get_network(network_id)
        network = Models::Network[network_id]
        raise "UnknownNetworkID" if network.nil?
        network.to_hash
      end

      def get_nic(nic_uuid)
        nic = Models::Taggable.find(nic_uuid)
        raise "UnknownNIC" if nic.nil?
        nic.to_hash
      end

      def get_instance_of_nic(nic_uuid)
        nic = Models::Taggable.find(nic_uuid)
        raise "UnknownNIC" if nic.nil?

        instance = nic.instance
        raise "UnknownInstance" if instance.nil?

        instance.to_hash
      end

      #Returns the current iplease for nic with uuid _nic_uuid_
      def get_iplease_for_nic(nic_uuid)
        nic = Models::Taggable.find(nic_uuid)
        raise "UnknownNIC" if nic.nil?
        Models::IpLease.find(:network_vif_id => nic[:id])[:ipv4]
      end

      def get_nat_leases(nic_uuid)
        #TODO: get this to work with non canonical uuid
        nic = Models::Taggable.find(nic_uuid)
        
        leases = Models::IpLease.filter({:network_vif_id => nic[:id]} & ~{:network_id => nic[:network_id]})
        leases.map {|l| l[:ipv4]}
      end

      def is_natted_ip?(ip)
        lease = Models::IpLease.find(:ipv4 => ip)
        
        return false if lease.nil?
            
        #lease.network_vif.network_id != lease.network_id  
        lease.is_natted?
      end

      def get_networks
        networks = Models::Network.all
        networks.map { |network|
          network.to_hash
        }
      end

      def get_host_nodes
        host_nodes = Models::HostNode.all
        host_nodes.map { |host_node| host_node.to_api_document }
      end

      def get_host_nodes_index
        host_nodes = Models::HostNode.all
        host_nodes.map { |host_node| host_node.canonical_uuid }
      end

      def get_host_node(host_node_uuid)
        host_node = Models::HostNode[host_node_uuid]
        raise "UnknownHostNodeID" if host_node.nil?
        host_node.to_api_document
      end

      def prepare_host_node_vnet(host_node_uuid, network_uuid)
        host_node = Models::HostNode[host_node_uuid]
        raise "UnknownHostNodeID" if host_node.nil?
        vnet = host_node.vnet.find { |vnet| vnet.network.canonical_uuid == network_uuid }

        if vnet.nil?
          network = Models::Network[network_uuid]
          raise "UnknownNetworkID" if network.nil?

          vnet = host_node.add_vnet(network)
        end

        vnet.to_api_document
      end

      def get_dhcp_conf(network_name)
        build_network_segment = proc { |network|
          nwaddr = network.ipv4_ipaddress
          h = {
            :uuid => network.canonical_uuid,
            :ipv4_first => nwaddr.first.to_s,
            :ipv4_last  => nwaddr.last.to_s,
            :ipv4_gw=> network.ipv4_gw,
            :netmask => nwaddr.prefix.to_ip,
            :prefix => network.prefix,
            :dns_server=> network.dns_server,
            :domain_name => network.domain_name,
            :metadata_server => network.metadata_server,
            :mac2addr => [],
            :addr2host=> [],
          }
          
          network.network_vif_ip_lease_dataset.filter(:alloc_type=>Models::NetworkVifIpLease::TYPE_AUTO).alives.each { |ip|
            # ignore IPs unbound to vnic.
            next if ip.network_vif.nil? || ip.network_vif.instance.nil?
            
            h[:mac2addr] << {
              :mac_addr => ip.network_vif.pretty_mac_addr,
              :ipaddr   => ip.ipv4
            }
            h[:addr2host] << {
              :hostname => ip.network_vif.fqdn_hostname,
              :ipaddr   => ip.network_vif.nat_network_id.nil? ? ip.ipv4 : ip.nat_outside_lease.ipv4 
            }
          }
          
          h
        }

        network_set = nil
        Tags::NetworkGroup
        Models::Network
        case network = Models::Taggable.find(network_name)
        when Models::Network
          network_set = [network]
        when Tags::NetworkGroup
          network_set = network.mapped_uuids.map {|m| Models::Network[m.uuid] }
        else
          raise "Unknown network name: #{network_name}"
        end

        h = {}
        network_set.each {|n|
          h[n.canonical_uuid] = build_network_segment.call(n)
        }
        h
      end
      
      def get_instance_monitor_data(node_id)
        hp = Models::HostNode.find(:node_id => node_id)
        instances = hp.instances.delete_if {|inst| inst[:state] != "running"}.map { |inst|
          {
          :uuid => inst.canonical_uuid,
          :hypervisor => hp.hypervisor,
          :status => inst.status
          }
        }
      end

      def get_instances_of_security_group(security_group_uuid)
        sg_map = Models::SecurityGroup[security_group_uuid]
        raise "Unknown security group ID: #{security_group_uuid}" if sg_map.nil?
        # do not include 'stopped' or 'scheduling' instances as they
        # are not allocated IP address.
        inst_maps = sg_map.network_vif_dataset.map { |vif|
          vif.instance_dataset.runnings.all.map { |inst| inst.to_hash }
        }.flatten.uniq.compact
        inst_maps
      end
      
      def get_vnics_of_security_group(security_group_uuid)
        group = Models::SecurityGroup[security_group_uuid]
        raise "Unknown security group ID: #{security_group_uuid}" if group.nil?
        # do not include 'stopped' or 'scheduling' instances as they
        # are not allocated IP address.
        vif_maps = group.network_vif_dataset.map { |vif| 
          vif.to_hash if vif.instance.state == "running"
        }.flatten.uniq.compact
        vif_maps
      end

      def get_security_groups_of_vnic(vnic_uuid)
        vnic = Models::NetworkVif[vnic_uuid]
        raise "Unknown vnic ID: #{vnic_uuid}" if vnic.nil?

        group_maps = vnic.security_groups_dataset.map { |group|
          group.to_hash
        }
        # }.flatten.uniq.compact
        group_maps
      end

      def get_alive_instances(node_id)
        hp = Models::HostNode.find(:node_id => node_id)
        if hp.nil?
          logger.error("The node ID is not bound to HostNode yet: #{node_id}")
          return []
        end
        inst_on_hp = hp.instances_dataset.runnings.all.map { |inst|
          inst.to_hash
        }
        inst_on_hp
      end

      # Methods for netfilter
      def get_referencers_of_security_group(group_id)
        Models::SecurityGroup[group_id].referencers.map { |ref|
            {
            :uuid => ref.canonical_uuid,
            :vnics => get_instances_of_security_group(ref.canonical_uuid).map { |inst_map| inst_map[:vif] }.flatten.uniq
            }
        }
      end

      def get_rules_of_security_group(group_id)
        secg_map = Models::SecurityGroup[group_id].to_hash
        
        secg_map[:rules]
      end
      
      def get_referencees_of_security_group(group_id)
        Models::SecurityGroup[group_id].referencees.map { |ref|
            {
            :uuid => ref.canonical_uuid,
            :vnics => get_instances_of_security_group(ref.canonical_uuid).map { |inst_map| inst_map[:vif] }.flatten.uniq
            }
        }
      end

      # Method designed to get all data needed for the netfilter service in a single request
      def get_netfilter_data(node_id)
        inst_maps = get_alive_instances(node_id)
        
        # Determine which security groups are in use
        secg_uuids = inst_maps.map { |inst_map|
          inst_map[:vif].map { |vif_map|
          vif_map[:security_groups]
          }
        }.flatten.uniq
        
        # Get the information of all security groups in use
        secg_maps = Models::SecurityGroup.map { |secg|
          if secg_uuids.member? secg.canonical_uuid
            secg_map = secg.to_hash
            
            # Store the vnics in a variable so we only need to ask the database once
            all_instances_in_group = get_instances_of_security_group(secg_map[:uuid])
            
            # Determine which vnics on this host are in this security group
            local_vnics = all_instances_in_group.map { |inst_map|
              if inst_map[:host_node][:node_id] == node_id
                inst_map[:vif].map { |vnic_map|
                  vnic_map if vnic_map[:security_groups].member?(secg_map[:uuid])
                }
              end
            }.flatten.uniq.compact
            
            # Determine which vnics on other hosts are also in this security group
            # Netfilter needs to know this for VM isolation
            foreign_vnics = all_instances_in_group.map { |inst_map|
              unless inst_map[:host_node][:node_id] == node_id
                inst_map[:vif].map { |vnic_map|
                  vnic_map if vnic_map[:security_groups].member?(secg_map[:uuid])
                }
              end
            }.flatten.uniq.compact
            
            referencee_maps = secg.referencees.map { |ref|
              {
              :uuid => ref.canonical_uuid,
              :vnics => get_vnics_of_security_group(ref.canonical_uuid)
              }
            }
            referencer_maps = secg.referencers.map { |ref|
              {
              :uuid => ref.canonical_uuid,
              :vnics => get_vnics_of_security_group(ref.canonical_uuid)
              }
            }
            
            secg_map.merge({:local_vnics => local_vnics, :foreign_vnics => foreign_vnics, :referencees => referencee_maps, :referencers => referencer_maps})
          end
        }.compact

        # Return the final hash
        {
          :security_groups => secg_maps
        }
      end

    end
  end
end
