# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'isono'
require 'trema'

module Dcmgr
  module NodeModules

    class ServiceOpenFlow < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::NicHelper

      config_section do
        desc "configuration file for ofc..."
      end
      
      initialize_hook do
        logger.info "initialize_hook for ofc..."

        # Trema hack...
        $verbose = true

        Dcmgr.run_initializers('sequel')

        EH = CustomEventHandler.new
        EH.set_as_handler

        Trema::Util::cleanup_current_session

        rule = {
          :port_status => "OpenFlowController",
          :packet_in => "OpenFlowController",
          :state_notify => "OpenFlowController"
        }

        # @switch_manager = Trema::SwitchManager.new( rule, nil, "/usr/share/axsh/wakame-vdc/ovs/var/run/openvswitch/br0.controller" )
        @switch_manager = Trema::SwitchManager.new( rule, 6633 )
        @switch_manager.run!

        @openflow_controller = OpenFlowController.new(myinstance)
        @openflow_controller.init_trema
        @openflow_controller.run_immediate!
        
        @worker_thread = Isono::ThreadPool.new(1, 'Openflow')
        @worker_thread.pass {
          myinstance.create_instance_map
        }

        event = Isono::NodeModules::EventChannel.new(node)

        event.subscribe('hva/instance_started', '#') do |args|
          @worker_thread.pass {
            logger.info("refresh on instance_started: #{args.inspect}")
            inst_id = args[0]
            logger.info("add_openflow_by_instance_id: #{inst_id}")
            myinstance.add_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/instance_terminated', '#') do |args|
          @worker_thread.pass {
            logger.info("refresh on instance_terminated: #{args.inspect}")
            inst_id = args[0]
            logger.info("delete_openflow_by_instance_id: #{inst_id}")
            myinstance.delete_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/openflow_updated', '#') do |args|
          @worker_thread.pass {
            logger.info("refresh on openflow_updated: #{args.inspect}")
            openflow_group_id = args[0]
            myinstance.refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
          }
        end

        logger.info "initialize_hook for ofc finished..."
      end

      terminate_hook do
        logger.info "terminate_hook for ofc..."

        @openflow_controller.stop_immediate!
        @openflow_controller.shutdown!

        Trema::Util::cleanup_current_session
      end

      def create_instance_map
        begin
          logger.info "Called create_instance_map..."

          inst_maps = rpc.request('hva-collector', 'get_alive_instances', node.node_id)

          viftable_map = {}
          inst_maps = inst_maps.map { |inst_map|
            viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

            logger.info "Instance... #{inst_map[:instance_nics].first[:uuid]} #{inst_map[:ips].first}."

            # Does the hva have instance?
            unless inst_map[:host_node][:node_id] == node.node_id
              logger.warn("no match for the instance: #{inst_map[:uuid]}")
              next
            end
            # Does host have vif?
            next unless valid_nic?(inst_map[:instance_nics].first[:uuid])
            inst_maps
          }.flatten.uniq.compact

          # init_iptables(inst_maps) if @node.manifest.config.enable_iptables
          # init_ebtables(inst_maps, viftable_map) if @node.manifest.config.enable_ebtables
          # init_static_nat(inst_maps) if @node.manifest.config.enable_iptables && @node.manifest.config.enable_ebtables
          # init_bandwidth_limit(networks = rpc.request('hva-collector', 'get_networks')) if @node.manifest.config.enable_iptables
          # sleep 1
        rescue Exception => e
          p e
        end
      end

      def add_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        vif_map = build_vif_map(inst_map)
        viftable_map = {}
        viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

        logger.info "Add OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        # Temporary tables for testing purposes.
        host_iptable_map[ vif_map[:ipv4] ] = vif_map[:mac]

        viftable_map.each { |k,v|
          logger.info "viftable: #{v} <=> #{k}"
          host_viftable_map[v] = k
        }
      end

      # Assume this gets called after receiving the port removed event
      # from OpenFlow Switch. Really need a better handling of these
      # events.
      def delete_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        #Create vnic map
        vif_map = build_vif_map(inst_map)

        logger.info "Deleting OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        #Calling build_ebtables_basic_part with the :delete flag will delete all jumps to this instance's chains and then delete the chains themselves
        # cmds << build_ebtables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_ebtables

        #Delete nat chains
        # if @node.manifest.config.enable_ebtables && @node.manifest.config.enable_iptables
        #   cmds << unlink_nat_chains(inst_map)
        #   cmds << stop_arp_reply(inst_map)
        #   cmds << build_nat_chains(inst_map, :delete)
        # end

        # #Delete iptables chains
        # cmds << build_iptables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_iptables

        # do_exec(cmds)
      end

      def refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
        raise "UnknownOpenflowGroupID" if openflow_group_id.nil?

        logger.info "Refresh Openflow..."

        # begin
        #   inst_maps = rpc.request('hva-collector', 'get_instances_of_netfilter_group', netfilter_group_id)
        #   init_netfilter if inst_maps.size > 0
        # rescue Exception => e
        #   p e
        # end
      end

      def build_vif_map(inst_map = {})
        vif_map = {
          :uuid  => inst_map[:instance_nics].first[:uuid],
          :mac   => clean_mac(inst_map[:instance_nics].first[:mac_addr]),
          :ipv4  => inst_map[:ips].first,
        }
      end

      # Use this for testing until we move to the new Task/Controller API.
      def host_iptable_map
        @host_iptable_map ||= {}
      end

      def host_viftable_map
        @host_viftable_map ||= {}
      end

      def port_status_map
        @port_status_map ||= {}
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end
    end


    #
    # Event handler glue for Trema.
    #

    $fd_set = {}

    module EventFdConnection
      def initialize connection
        @connection = connection
      end

      def notify_readable
        @connection.notify_readable
      end

      def notify_writable
        @connection.notify_writable
      end

      def unbind
        # EM.next_tick do
        #   # socket is detached from the eventloop, but still open
        #   data = @io.read
        # end
      end  
    end


    class CustomEventHandler < Trema::EventHandler
      include Dcmgr::Logger

      def init_event_handler
        logger.info "Called CustomEventHandler init_event_handler."
      end

      def finalize_event_handler
        logger.info "Called CustomEventHandler finalize_event_handler."
      end

      def stop_event_handler
        logger.info "Called CustomEventHandler stop_event_handler."
        EM.stop
      end

      def run_event_handler_once
        logger.info "Called CustomEventHandler run_event_handler_once."
      end
      
      def set_fd_handler fd, connection
        logger.info "Called CustomEventHandler immediate set_fd_handler, #{fd}."
        
        $fd_set[ fd ] = EM.watch fd, EventFdConnection, connection
      end
      
      def delete_fd_handler fd
        logger.info "Called CustomEventHandler delete_fd_handler, #{fd}."
        connection = $fd_set[ fd ]
        $fd_set[ fd ] = nil

        connection.detach
      end

      def set_readable fd, state
        # logger.debug "Called CustomEventHandler set_readable, #{fd}."

        if fd < 0
          logger.error "Called set_readable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_readable = state
      end

      def set_writable fd, state
        # logger.debug "Called CustomEventHandler set_writable, #{fd}."

        if fd < 0
          logger.error "Called set_writable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_writable = state
      end

      def readable fd
        logger.debug "Called CustomEventHandler readable, #{fd}."
      end

      def writable fd
        logger.debug "Called CustomEventHandler writable, #{fd}."
      end

    end

  end
end
