# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'isono'
require 'trema'

module Dcmgr
  module NodeModules

    class ServiceOpenFlow < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::NicHelper

      config_section do
        desc "configuration file for ofc..."
      end
      
      initialize_hook do
        logger.info "initialize_hook for ofc..."

        # Trema hack...
        $verbose = true

        Dcmgr.run_initializers('sequel')

        EH = CustomEventHandler.new
        EH.set_as_handler

        Trema::Util::cleanup_current_session

        rule = {
          :port_status => "OpenFlowController",
          :packet_in => "OpenFlowController",
          :state_notify => "OpenFlowController"
        }

        @switch_manager = Trema::SwitchManager.new( rule, nil, "/usr/share/axsh/wakame-vdc/ovs/var/run/openvswitch/br0.controller" )
        # @switch_manager = Trema::SwitchManager.new( rule, 6633 )
        @switch_manager.run!

        myinstance.openflow_controller.init_trema
        myinstance.openflow_controller.run_immediate!
        
        myinstance.worker_thread.pass {
          myinstance.create_instance_map
        }

        event = Isono::NodeModules::EventChannel.new(node)

        event.subscribe('hva/instance_started', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on instance_started: #{args.inspect}")
            inst_id = args[0]
            logger.info("add_openflow_by_instance_id: #{inst_id}")
            myinstance.add_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/instance_terminated', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on instance_terminated: #{args.inspect}")
            inst_id = args[0]
            logger.info("delete_openflow_by_instance_id: #{inst_id}")
            myinstance.delete_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/openflow_updated', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on openflow_updated: #{args.inspect}")
            openflow_group_id = args[0]
            myinstance.refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
          }
        end

        logger.info "initialize_hook for ofc finished..."
      end

      terminate_hook do
        logger.info "terminate_hook for ofc..."

        myinstance.openflow_controller.stop_immediate!
        myinstance.openflow_controller.shutdown!

        Trema::Util::cleanup_current_session
      end

      def create_instance_map
        begin
          logger.info "Called create_instance_map..."

          inst_maps = rpc.request('hva-collector', 'get_alive_instances', node.node_id)

          viftable_map = {}
          inst_maps = inst_maps.map { |inst_map|
            viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

            logger.info "Instance... #{inst_map[:instance_nics].first[:uuid]} #{inst_map[:ips].first}."

            # Does the hva have instance?
            unless inst_map[:host_node][:node_id] == node.node_id
              logger.warn("no match for the instance: #{inst_map[:uuid]}")
              next
            end
            # Does host have vif?
            next unless valid_nic?(inst_map[:instance_nics].first[:uuid])
            inst_maps
          }.flatten.uniq.compact

          # init_iptables(inst_maps) if @node.manifest.config.enable_iptables
          # init_ebtables(inst_maps, viftable_map) if @node.manifest.config.enable_ebtables
          # init_static_nat(inst_maps) if @node.manifest.config.enable_iptables && @node.manifest.config.enable_ebtables
          # init_bandwidth_limit(networks = rpc.request('hva-collector', 'get_networks')) if @node.manifest.config.enable_iptables
          # sleep 1
        rescue Exception => e
          p e
        end
      end

      def add_openflow_instance(vif_map, viftable_map)
        logger.info "Adding OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        # Temporary tables for testing purposes.
        host_iptable_map[ vif_map[:ipv4] ] = vif_map[:mac]

        viftable_map.each { |k,v|
          logger.info "viftable: #{v} <=> #{k}"
          host_viftable_map[v] = k
        }
      end

      def add_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        vif_map = {
          :uuid  => inst_map[:instance_nics].first[:uuid],
          :mac   => clean_mac(inst_map[:instance_nics].first[:mac_addr]),
          :ipv4  => inst_map[:ips].first,
        }
        viftable_map = {}
        viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

        add_openflow_instance(vif_map, viftable_map)
      end

      def add_openflow_by_nic(nic_uuid)
        raise ArgumentError, "Unknown Nic: #{nic_uuid}" if nic_uuid.nil?
        nic_map = rpc.request('hva-collector', 'get_nic', nic_uuid)
        ip_lease = rpc.request('hva-collector', 'get_iplease_for_nic', nic_uuid)
        raise ArgumentError, "Unknown Nic: #{nic_uuid}" if nic_map.nil?
        raise ArgumentError, "Unknown Nic: #{nic_uuid}" if ip_lease.nil?
        
        vif_map = {
          :uuid  => nic_uuid,
          :mac   => clean_mac(nic_map[:mac_addr]),
          :ipv4  => ip_lease
        }
        viftable_map = {}
        viftable_map[ ip_lease ] = nic_uuid

        add_openflow_instance(vif_map, viftable_map)
      end

      # Assume this gets called after receiving the port removed event
      # from OpenFlow Switch. Really need a better handling of these
      # events.
      def delete_openflow_instance(vif_map)
        logger.info "Deleting OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        openflow_controller.remove_route         vif_map[:port], vif_map[:mac], vif_map[:ipv4]
        openflow_controller.remove_arp_antispoof vif_map[:port], vif_map[:mac], vif_map[:ipv4]


        #Calling build_ebtables_basic_part with the :delete flag will delete all jumps to this instance's chains and then delete the chains themselves
        # cmds << build_ebtables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_ebtables

        #Delete nat chains
        # if @node.manifest.config.enable_ebtables && @node.manifest.config.enable_iptables
        #   cmds << unlink_nat_chains(inst_map)
        #   cmds << stop_arp_reply(inst_map)
        #   cmds << build_nat_chains(inst_map, :delete)
        # end

        # #Delete iptables chains
        # cmds << build_iptables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_iptables

        # do_exec(cmds)
      end

      def delete_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        port_status = port_status_map.detect { |f| f[1][:nic_id] == inst_map[:instance_nics].first[:uuid] }

        raise "UnknownOpenflowPort" if port_status.nil?
        raise "UnknownOpenflowPort" if port_status[1][:last_ipv4].nil?

        vif_map = {
          :uuid  => inst_map[:instance_nics].first[:uuid],
          :mac   => clean_mac(inst_map[:instance_nics].first[:mac_addr]),
          :ipv4  => port_status[1][:last_ipv4],
          :port  => port_status[0]
        }

        delete_openflow_instance vif_map
      end

      def refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
        raise "UnknownOpenflowGroupID" if openflow_group_id.nil?

        logger.info "Refresh Openflow..."

        # begin
        #   inst_maps = rpc.request('hva-collector', 'get_instances_of_netfilter_group', netfilter_group_id)
        #   init_netfilter if inst_maps.size > 0
        # rescue Exception => e
        #   p e
        # end
      end

      #
      #
      #

      def add_instance port_info
        if not port_status_map.has_key? port_info.number or
            port_status_map[ port_info.number ][ :is_active ] == false
          logger.info "Cancelled add_instance: #{port_info.name}..."
          return
        end

        if not host_viftable_map.has_key? port_info.name
          EM.add_timer(10) { self.add_instance port_info }
          logger.info "Postponing add_instance: #{port_info.name}..."
          return;
        end

        raise "UnknownOpenflowPort" if not port_status_map.has_key? port_info.number

        inside_ip = host_viftable_map[port_info.name]
        inside_hw = host_iptable_map[inside_ip]

        port_status_map[port_info.number][:last_ipv4] = inside_ip

        logger.info "adding instance #{port_info.name}."
        logger.info "port: #{port_info.number}"
        logger.info "mac: #{port_info.hw_addr.to_s} <=> #{inside_hw}"
        logger.info "ip: #{inside_ip}"
        logger.info "config: #{port_info.config}"
        logger.info "state: #{port_info.state}"
        logger.info "curr: #{port_info.curr}"
        logger.info "advertised: #{port_info.advertised}"
        logger.info "supported: #{port_info.supported}"
        logger.info "peer: #{port_info.peer}"

        openflow_controller.install_route         port_info.number, inside_hw, inside_ip
        openflow_controller.install_arp_antispoof port_info.number, inside_hw, inside_ip
      end

      # Use this for testing until we move to the new Task/Controller API.
      def host_iptable_map
        @host_iptable_map ||= {}
      end

      def host_viftable_map
        @host_viftable_map ||= {}
      end

      def port_status_map
        @port_status_map ||= {}
      end

      def openflow_controller
        @openflow_controller ||= OpenFlowController.new(self)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def worker_thread
        @worker_thread ||= Isono::ThreadPool.new(1, 'Openflow')
      end
    end


    #
    # Event handler glue for Trema.
    #

    $fd_set = {}

    module EventFdConnection
      def initialize connection
        @connection = connection
      end

      def notify_readable
        @connection.notify_readable
      end

      def notify_writable
        @connection.notify_writable
      end

      def unbind
        # EM.next_tick do
        #   # socket is detached from the eventloop, but still open
        #   data = @io.read
        # end
      end  
    end


    class CustomEventHandler < Trema::EventHandler
      include Dcmgr::Logger

      def init_event_handler
        logger.info "Called CustomEventHandler init_event_handler."
      end

      def finalize_event_handler
        logger.info "Called CustomEventHandler finalize_event_handler."
      end

      def stop_event_handler
        logger.info "Called CustomEventHandler stop_event_handler."
        EM.stop
      end

      def run_event_handler_once
        logger.info "Called CustomEventHandler run_event_handler_once."
      end
      
      def set_fd_handler fd, connection
        logger.info "Called CustomEventHandler immediate set_fd_handler, #{fd}."
        
        $fd_set[ fd ] = EM.watch fd, EventFdConnection, connection
      end
      
      def delete_fd_handler fd
        logger.info "Called CustomEventHandler delete_fd_handler, #{fd}."
        connection = $fd_set[ fd ]
        $fd_set[ fd ] = nil

        connection.detach
      end

      def set_readable fd, state
        # logger.debug "Called CustomEventHandler set_readable, #{fd}."

        if fd < 0
          logger.error "Called set_readable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_readable = state
      end

      def set_writable fd, state
        # logger.debug "Called CustomEventHandler set_writable, #{fd}."

        if fd < 0
          logger.error "Called set_writable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_writable = state
      end

      def readable fd
        logger.debug "Called CustomEventHandler readable, #{fd}."
      end

      def writable fd
        logger.debug "Called CustomEventHandler writable, #{fd}."
      end

    end

  end
end
