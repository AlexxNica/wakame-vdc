# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'isono'
require 'fileutils'
require 'trema'

module Dcmgr
  module NodeModules

    class ServiceOpenFlow < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::NicHelper

      config_section do
        desc "configuration file for ofc..."
      end
      
      initialize_hook do
        logger.info "initialize_hook for ofc..."

        # Trema hack...
        $verbose = true

        Dcmgr.run_initializers('sequel')

        EH = CustomEventHandler.new
        EH.set_as_handler

        Trema::Util::cleanup_current_session

        rule = {
          :port_status => "OpenFlowController",
          :packet_in => "OpenFlowController",
          :state_notify => "OpenFlowController"
        }

        unix_socket = "#{node.manifest.config.ovs_run_dir}/#{node.manifest.config.bridge_novlan}.controller"

        FileUtils.remove_file(unix_socket, true)

        @switch_manager = Trema::SwitchManager.new( rule, nil, unix_socket )
        @switch_manager.run!

        myinstance.openflow_controller.init_trema
        myinstance.openflow_controller.run_immediate!
        
        event = Isono::NodeModules::EventChannel.new(node)

        event.subscribe('hva/instance_started', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on instance_started: #{args.inspect}")
            inst_id = args[0]
            logger.info("add_openflow_by_instance_id: #{inst_id}")
            myinstance.add_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/instance_terminated', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on instance_terminated: #{args.inspect}")
            inst_id = args[0]
            myinstance.delete_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/openflow_updated', '#') do |args|
          myinstance.worker_thread.pass {
            logger.info("refresh on openflow_updated: #{args.inspect}")
            openflow_group_id = args[0]
            myinstance.refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
          }
        end

        logger.info "initialize_hook for ofc finished..."
      end

      terminate_hook do
        logger.info "terminate_hook for ofc..."

        myinstance.openflow_controller.stop_immediate!
        myinstance.openflow_controller.shutdown!

        Trema::Util::cleanup_current_session
      end

      def add_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        port = openflow_controller.ports.detect { |f| f[1].port_info.name == inst_map[:instance_nics].first[:uuid] }

        add_instance_now port[1] if not port.nil?
      end

      def delete_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        port = openflow_controller.ports.detect { |f| f[1].port_info.name == inst_map[:instance_nics].first[:uuid] }

        delete_instance_now port[1] if not port.nil?
      end

      def refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
        raise "UnknownOpenflowGroupID" if openflow_group_id.nil?

        logger.info "Refresh Openflow..."
      end

      #
      #
      #

      # Always call in the worker thread.
      #
      # TODO: Consider just passing OpenFlowPort.
      def add_instance port
        worker_thread.pass { add_instance_now port }
      end

      def add_instance_now port
        return if port.has_instance

        nic_map = rpc.request('hva-collector', 'get_nic', port.port_info.name)
        ip_lease = rpc.request('hva-collector', 'get_iplease_for_nic', port.port_info.name)
        mac_lease = clean_mac(nic_map[:mac_addr])

        raise ArgumentError, "Unknown Nic: #{port.port_info.name}" if nic_map.nil?
        raise ArgumentError, "Unknown Nic: #{port.port_info.name}" if ip_lease.nil?

        port.ip = ip_lease
        port.mac = mac_lease
        port.has_instance = true

        logger.info "adding instance #{port.port_info.name}."
        logger.info "port: #{port.port_info.number}"
        logger.info "mac: #{port.port_info.hw_addr.to_s} <=> #{mac_lease}"
        logger.info "ip: #{ip_lease}"
        logger.info "config: #{port.port_info.config}"
        logger.info "state: #{port.port_info.state}"
        logger.info "curr: #{port.port_info.curr}"
        logger.info "advertised: #{port.port_info.advertised}"
        logger.info "supported: #{port.port_info.supported}"
        logger.info "peer: #{port.port_info.peer}"

        # TODO: Make sure these use the OpenFlowController thread...
        openflow_controller.install_route         port.port_info.number, mac_lease, ip_lease
        openflow_controller.install_arp_antispoof port.port_info.number, mac_lease, ip_lease
      end

      # Always call in the worker thread.
      #
      # TODO: Consider just passing OpenFlowPort.
      def delete_instance port
        worker_thread.pass { delete_instance_now port }
      end

      def delete_instance_now port
        return if not port.has_instance

        ip_lease = port.ip
        mac_lease = port.mac

        port.ip = nil
        port.mac = nil
        port.has_instance = false

        logger.info "deleting instance #{port.port_info.name}."
        logger.info "port: #{port.port_info.number}"
        logger.info "mac: #{port.port_info.hw_addr.to_s} <=> #{mac_lease}"
        logger.info "ip: #{ip_lease}"
        logger.info "config: #{port.port_info.config}"
        logger.info "state: #{port.port_info.state}"
        logger.info "curr: #{port.port_info.curr}"
        logger.info "advertised: #{port.port_info.advertised}"
        logger.info "supported: #{port.port_info.supported}"
        logger.info "peer: #{port.port_info.peer}"

        openflow_controller.remove_route         port.port_info.number, mac_lease, ip_lease
        openflow_controller.remove_arp_antispoof port.port_info.number, mac_lease, ip_lease
      end

      def openflow_controller
        @openflow_controller ||= OpenFlowController.new(self)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def worker_thread
        @worker_thread ||= Isono::ThreadPool.new(1, 'Openflow')
      end
    end


    #
    # Event handler glue for Trema.
    #

    $fd_set = {}

    module EventFdConnection
      def initialize connection
        @connection = connection
      end

      def notify_readable
        @connection.notify_readable
      end

      def notify_writable
        @connection.notify_writable
      end

      def unbind
        # EM.next_tick do
        #   # socket is detached from the eventloop, but still open
        #   data = @io.read
        # end
      end  
    end


    class CustomEventHandler < Trema::EventHandler
      include Dcmgr::Logger

      def init_event_handler
        logger.info "Called CustomEventHandler init_event_handler."
      end

      def finalize_event_handler
        logger.info "Called CustomEventHandler finalize_event_handler."
      end

      def stop_event_handler
        logger.info "Called CustomEventHandler stop_event_handler."
        EM.stop
      end

      def run_event_handler_once
        logger.info "Called CustomEventHandler run_event_handler_once."
      end
      
      def set_fd_handler fd, connection
        logger.info "Called CustomEventHandler immediate set_fd_handler, #{fd}."
        
        $fd_set[ fd ] = EM.watch fd, EventFdConnection, connection
      end
      
      def delete_fd_handler fd
        logger.info "Called CustomEventHandler delete_fd_handler, #{fd}."
        connection = $fd_set[ fd ]
        $fd_set[ fd ] = nil

        connection.detach
      end

      def set_readable fd, state
        # logger.debug "Called CustomEventHandler set_readable, #{fd}."

        if fd < 0
          logger.error "Called set_readable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_readable = state
      end

      def set_writable fd, state
        # logger.debug "Called CustomEventHandler set_writable, #{fd}."

        if fd < 0
          logger.error "Called set_writable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_writable = state
      end

      def readable fd
        logger.debug "Called CustomEventHandler readable, #{fd}."
      end

      def writable fd
        logger.debug "Called CustomEventHandler writable, #{fd}."
      end

    end

  end
end
