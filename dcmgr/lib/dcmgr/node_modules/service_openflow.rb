# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'eventmachine'
require 'isono'
#require 'ipaddress'
require 'trema'

module Dcmgr
  module NodeModules

    class ServiceOpenFlow < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::NicHelper

      config_section do
        desc "configuration file for ofc..."
      end
      
      initialize_hook do
        logger.info "initialize_hook for ofc..."

        # Trema hack...
        $verbose = true

        Dcmgr.run_initializers('sequel')

        EH = CustomEventHandler.new
        EH.set_as_handler

        Trema::Util::cleanup_current_session

        rule = {
          :port_status => "OpenFlowController",
          :packet_in => "OpenFlowController",
          :state_notify => "OpenFlowController"
        }

        @switch_manager = Trema::SwitchManager.new( rule, 6633 )
        @switch_manager.run!

        @openflow_controller = OpenFlowController.new(myinstance)
        @openflow_controller.init_trema
        @openflow_controller.run_immediate!
        
        @worker_thread = Isono::ThreadPool.new(1, 'Openflow')
        @worker_thread.pass {
          myinstance.create_instance_map
        }

        event = Isono::NodeModules::EventChannel.new(node)

        event.subscribe('hva/instance_started', '#') do |args|
          @worker_thread.pass {
            logger.info("refresh on instance_started: #{args.inspect}")
            inst_id = args[0]
            logger.info("add_openflow_by_instance_id: #{inst_id}")
            myinstance.add_openflow_by_instance_id(inst_id)
          }
        end

        event.subscribe('hva/instance_terminated', '#') do |args|
          @worker_thread.pass {
            logger.info("refresh on instance_terminated: #{args.inspect}")
            inst_id = args[0]
            logger.info("delete_openflow_by_instance_id: #{inst_id}")
            myinstance.delete_openflow_by_instance_id(inst_id)
          }
        end

        # event.subscribe('hva/openflow_updated', '#') do |args|
        #   @worker_thread.pass {
        #     logger.info("refresh on openflow_updated: #{args.inspect}")
        #     openflow_group_id = args[0]
        #     myinstance.refresh_openflow_by_joined_openflow_group_id(openflow_group_id)
        #   }
        # end

        logger.info "initialize_hook for ofc finished..."
      end

      terminate_hook do
        logger.info "terminate_hook for ofc..."

        @openflow_controller.stop_immediate!
        @openflow_controller.shutdown!

        Trema::Util::cleanup_current_session
      end

      def create_instance_map
        begin
          logger.info "Called create_instance_map..."

          inst_maps = rpc.request('hva-collector', 'get_alive_instances', node.node_id)

          viftable_map = {}
          inst_maps = inst_maps.map { |inst_map|
            viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

            logger.info "Instance... #{inst_map[:instance_nics].first[:uuid]} #{inst_map[:ips].first}."

            # Does the hva have instance?
            unless inst_map[:host_node][:node_id] == node.node_id
              logger.warn("no match for the instance: #{inst_map[:uuid]}")
              next
            end
            # Does host have vif?
            next unless valid_nic?(inst_map[:instance_nics].first[:uuid])
            inst_maps
          }.flatten.uniq.compact

          # init_iptables(inst_maps) if @node.manifest.config.enable_iptables
          # init_ebtables(inst_maps, viftable_map) if @node.manifest.config.enable_ebtables
          # init_static_nat(inst_maps) if @node.manifest.config.enable_iptables && @node.manifest.config.enable_ebtables
          # init_bandwidth_limit(networks = rpc.request('hva-collector', 'get_networks')) if @node.manifest.config.enable_iptables
          # sleep 1
        rescue Exception => e
          p e
        end
      end

      def add_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        vif_map = build_vif_map(inst_map)
        viftable_map = {}
        viftable_map[ inst_map[:ips].first ] = inst_map[:instance_nics].first[:uuid]

        logger.info "Add OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        # Temporary tables for testing purposes.
        host_iptable_map[ vif_map[:ipv4] ] = vif_map[:mac]

        viftable_map.each { |k,v|
          logger.info "viftable: #{v} <=> #{k}"
          host_viftable_map[v] = k
        }
      end

      # Assume this gets called after receiving the port removed event
      # from OpenFlow Switch. Really need a better handling of these
      # events.
      def delete_openflow_by_instance_id(inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_id.nil?
        inst_map = rpc.request('hva-collector', 'get_instance', inst_id)
        raise ArgumentError, "Unknown Instance ID: #{inst_id}" if inst_map.nil?

        #Create vnic map
        vif_map = build_vif_map(inst_map)

        logger.info "Deleting OpenFlow instance: uuid:#{vif_map[:uuid]} mac:#{vif_map[:mac]} ipv4:#{vif_map[:ipv4]}."

        #Calling build_ebtables_basic_part with the :delete flag will delete all jumps to this instance's chains and then delete the chains themselves
        # cmds << build_ebtables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_ebtables

        #Delete nat chains
        # if @node.manifest.config.enable_ebtables && @node.manifest.config.enable_iptables
        #   cmds << unlink_nat_chains(inst_map)
        #   cmds << stop_arp_reply(inst_map)
        #   cmds << build_nat_chains(inst_map, :delete)
        # end

        # #Delete iptables chains
        # cmds << build_iptables_basic_part(vif_map, inst_map, :delete) if @node.manifest.config.enable_iptables

        # do_exec(cmds)
      end

      def build_vif_map(inst_map = {})
        vif_map = {
          :uuid  => inst_map[:instance_nics].first[:uuid],
          :mac   => clean_mac(inst_map[:instance_nics].first[:mac_addr]),
          :ipv4  => inst_map[:ips].first,
        }
      end

      # Use this for testing until we move to the new Task/Controller API.
      def host_iptable_map
        @host_iptable_map ||= {}
      end

      def host_viftable_map
        @host_viftable_map ||= {}
      end

      def port_status_map
        @port_status_map ||= {}
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end
    end

    #
    # OpenFlow controller
    #

    class OpenFlowController < Trema::Controller
      include Dcmgr::Logger

      M=Dcmgr::Models

      def initialize service_openflow
        @service_openflow = service_openflow
      end

      def start
        logger.info "OpenFlowController Thread Object Id: #{Thread.current}."
        logger.info "Instances db: #{self.name}, #{Trema::App[self.name]}."

        @fdb_incoming = OpenFlowForwardingDatabase.new
        @fdb_outgoing = OpenFlowForwardingDatabase.new
      end

      def print_foo
        logger.info "OpenFlowController #{Thread.current}: finished start."
      end

      def switch_ready datapath_id
        logger.info "switch_ready from %#x." % datapath_id

        # There's a short period of time between the switch being
        # activated and features_reply installing flow.
        send_message datapath_id, Trema::FeaturesRequest.new
      end

      def features_reply message
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "transaction_id: %#x" % message.transaction_id
        logger.info "n_buffers: %u" % message.n_buffers
        logger.info "n_tables: %u" % message.n_tables
        logger.info "capabilities: %u" % message.capabilities
        logger.info "actions: %u" % message.actions
        logger.info "ports: %s" % message.ports.collect { | each | each.number }.sort.join( ", " )

        send_flow_mod_add(message.datapath_id,
                          :match => Trema::Match.new( ),
                          :priority => 0x0,
                          :actions => Trema::ActionOutput.new( :port => OFPP_NORMAL ) )

        # Send to controller all unmatched packets destined for the
        # meta-data server, and let the controller install the needed
        # flows.
        send_flow_mod_add(message.datapath_id,
                          :match => Trema::Match.new( :dl_type => 0x0800, :nw_proto => 6, :nw_dst => "169.254.169.254", :tp_dst => 80 ),
                          :priority => 0x010,
                          :actions => Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) )

        message.ports.each do | each |
#          logger.info "Found port: port:#{each.number} mac:#{each.hw_addr.to_s} name:#{each.name} config:#{each.config} state:#{each.state} curr:#{each.curr} advertised:#{each.advertised} supported:#{each.supported} peer:#{each.peer}."

          # Need to look at the datalink address, not guess at numbers.
          #
          # TODO: Move handling of this into a dedicated function.
          if each.number == 1
            # Don't allow packets from the network to reach the controller.
            send_flow_mod_add(message.datapath_id,
                              :match => Trema::Match.new( :in_port => each.number, :dl_type => 0x0800, :nw_proto => 6, :nw_dst => "169.254.169.254", :tp_dst => 80 ),
                              :priority => 0x200 )

          elsif each.number > 1 and each.number < OFPP_MAX
            @service_openflow.port_status_map[ each.number ] = {
              :is_active => true
            }

            add_instance message.datapath_id, each
          elsif each.number == OFPP_LOCAL
            logger.info "OFPP_LOCAL setting hw_addr = %s" % each.hw_addr.to_s
            @local_hw = each.hw_addr
          elsif each.number >= OFPP_MAX
          else

          end
        end
      end

      def port_status message
        logger.info "port_status from %#x" % message.datapath_id
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "reason: #{message.reason}"
        logger.info "in_port: #{message.phy_port.number}"
        logger.info "hw_addr: #{message.phy_port.hw_addr}"
        logger.info "state: %#x" % message.phy_port.state

        case message.reason
        when OFPPR_ADD
          @service_openflow.port_status_map[ message.phy_port.number ] = {
            :is_active => true
          }

          add_instance message.datapath_id, message.phy_port
        when OFPPR_DELETE
          @service_openflow.port_status_map[ message.phy_port.number ] = {
            :is_active => false
          }

          logger.info "Deleting port..."
        when OFPPR_MODIFY
          logger.info "Ignoring port modify..."
        end
      end

      def packet_in datapath_id, message
        # logger.info "Got a packet: datapath_id:%#x in_port:#{message.in_port}, macsa:#{message.macsa}, macda:#{message.macda}, port_no:." % datapath_id

        # Install DNAT route if we get a new connection destined for the
        # meta-data server.

        # We handle all ARP packets in the controller.
        if message.arp?
          # Also check the in_port...
          out_packet = Trema::PacketOut.from message

          if arp_translate_incoming_map.has_key? message.arp_tpa.to_s
            new_values = arp_translate_incoming_map[message.arp_tpa.to_s]
            out_packet.arp_tpa = Trema::IP.new( new_values[:nw_dst] ).to_i

          elsif arp_translate_outcoming_map.has_key? message.arp_spa.to_s
            new_values = arp_translate_outcoming_map[message.arp_spa.to_s]
            out_packet.arp_spa = Trema::IP.new( new_values[:nw_src] ).to_i

          else
            logger.info "No entries for ARP packet."
            return
          end

          # logger.info "Rewriting incoming ARP packet: #{message.arp_tpa.to_s} => nw_src:#{new_values[:nw_src]} nw_dst:#{new_values[:nw_dst]} output:#{new_values[:output]}."

          new_values[:output].each { | out_port |
            send_packet_out(datapath_id,
                            :data => out_packet.to_s,
                            :actions => Trema::ActionOutput.new( :port => out_port ) )
          }
          return
        end

        # Need to use ExactMatch due to lack of proper facilities for
        # inspecting packets.
        tmp_msg = Trema::ExactMatch.from( message )

        logger.info "Matching: %#x #{tmp_msg.nw_proto} #{Trema::IP.new( tmp_msg.nw_dst ).to_s} #{Trema::IP.new( tmp_msg.nw_src ).to_s} #{tmp_msg.tp_dst} #{tmp_msg.tp_src}." % tmp_msg.dl_type

        if tmp_msg.dl_type == 0x0800 and tmp_msg.nw_proto == 6 and Trema::IP.new( tmp_msg.nw_dst ).to_s == "169.254.169.254" and tmp_msg.tp_dst == 80
          install_dnat_entry datapath_id, tmp_msg, OFPP_LOCAL, @local_hw, "192.168.2.23", 9002
          send_packet_out(datapath_id, :packet_in => message, :actions => Trema::ActionOutput.new( :port => OFPP_TABLE ) )
        end

      end

      def arp_translate_incoming_map
        @arp_translate_incoming_map ||= {}
      end

      def arp_translate_outcoming_map
        @arp_translate_outcoming_map ||= {}
      end

      #
      # Private methods:
      #
      private

      def add_instance datapath_id, port_info
        if not @service_openflow.port_status_map.has_key? port_info.number or
            @service_openflow.port_status_map[ port_info.number ][ :is_active ] == false
          logger.info "Cancelled add_instance: #{port_info.name}..."
          return
        end

        if not @service_openflow.host_viftable_map.has_key? port_info.name
          EM.add_timer(5) { add_instance datapath_id, port_info }
          logger.info "Postponing add_instance: #{port_info.name}..."
          return;
        end

        inside_ip = @service_openflow.host_viftable_map[port_info.name]
        inside_hw = @service_openflow.host_iptable_map[inside_ip]

        logger.info "Adding instance: port:#{port_info.number} mac:#{port_info.hw_addr.to_s} name:#{port_info.name} config:#{port_info.config} state:#{port_info.state} curr:#{port_info.curr} advertised:#{port_info.advertised} supported:#{port_info.supported} peer:#{port_info.peer}."

        install_snat_entry datapath_id, port_info.number, inside_hw, inside_ip, OFPP_NORMAL, inside_hw, "192.168.2.222"
      end

      def install_dnat_entry datapath_id, message, dest_port, dest_hw, dest_ip, dest_tp
        logger.info "Installing DNAT entry: #{dest_port} #{dest_hw} #{dest_ip}:#{dest_tp}"

        send_flow_mod_add(datapath_id,
                          :match => Trema::Match.new( :in_port => message.in_port, :dl_type => message.dl_type, :nw_proto => message.nw_proto,
                                                      :dl_src => message.dl_src.to_s, :dl_dst => message.dl_dst.to_s,
                                                      :nw_src => message.nw_src, :nw_dst => message.nw_dst,
                                                      :tp_src => message.tp_src, :tp_dst => message.tp_dst ),
                          :priority => 0x101,
                          :idle_timeout => 300,
                          :actions => [ Trema::ActionSetDlDst.new( :dl_dst => dest_hw ),
                                        Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new( dest_ip ) ),
                                        Trema::ActionSetTpDst.new( :tp_dst => dest_tp ),
                                        Trema::ActionOutput.new( :port => dest_port ) ] )

        send_flow_mod_add(datapath_id,
                          :match => Trema::Match.new( :in_port => dest_port, :dl_type => message.dl_type, :nw_proto => message.nw_proto,
                                                      :dl_src => dest_hw.to_s, :dl_dst => message.dl_src.to_s,
                                                      :nw_src => dest_ip, :nw_dst => message.nw_src,
                                                      :tp_src => dest_tp, :tp_dst => message.tp_src ),
                          :priority => 0x101,
                          :idle_timeout => 300,
                          :actions => [ Trema::ActionSetDlSrc.new( :dl_src => message.dl_dst ),
                                        Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new( message.nw_dst ) ),
                                        Trema::ActionSetTpSrc.new( :tp_src => message.tp_dst ),
                                        Trema::ActionOutput.new( :port => message.in_port ) ] )
      end

      def install_snat_entry datapath_id, inside_port, inside_hw, inside_ip, outside_port, outside_hw, outside_ip
        # TODO: Verify that the outside_port is valid.

        #dest_inside_port = (inside_port == OFPP_ALL ? OFPP_NORMAL : inside_port)
        #dest_outside_port = (outside_port == OFPP_ALL ? OFPP_NORMAL : outside_port)

        logger.info "Installing StaticNAT entry: inside:'#{inside_port} #{inside_hw} #{inside_ip}' outside:'#{outside_port} #{outside_hw} #{outside_ip}'"

        # Currently we're using OFPP_TABLE to ensure modifications get
        # done and the packet gets sent for processing. We need to add
        # our own ARP table in order to route packets without this
        # hack.
        dest_outside_port = outside_port == OFPP_NORMAL ? OFPP_TABLE : outside_port;

        # Translate ARP packets.
        send_flow_mod_add(datapath_id,
                          :match => outside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0806, :nw_dst => outside_ip ) :
                          Trema::Match.new( :in_port => outside_port, :dl_type => 0x0806, :nw_dst => outside_ip ),
                          :priority => 0x100,
                          :actions => [ # Trema::ActionSetDlDst.new( :dl_dst => Trema::Mac.new(inside_hw) ),
                                        # Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new(inside_ip) ),
                                        Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) ] )
        send_flow_mod_add(datapath_id,
                          :match => inside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0806,
                                            :dl_src => inside_hw, :nw_src => inside_ip ) :
                          Trema::Match.new( :in_port => inside_port, :dl_type => 0x0806,
                                            :dl_src => inside_hw, :nw_src => inside_ip ),
                          :priority => 0x100,
                          :actions => [ # Trema::ActionSetDlSrc.new( :dl_src => Trema::Mac.new(outside_hw) ),
                                        # Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new(outside_ip) ),
                                        Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) ] )

        # Hack that is not really safe.
        arp_translate_incoming_map[outside_ip] = { :nw_dst => inside_ip, :output => [ inside_port ] }
        arp_translate_outcoming_map[inside_ip] = { :nw_src => outside_ip, :output => [ OFPP_LOCAL, 1 ] }

        # Translate IP packets.
        send_flow_mod_add(datapath_id,
                          :match => outside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0800,
                                            :dl_dst => outside_hw, :nw_dst => outside_ip ) :
                          Trema::Match.new( :in_port => outside_port, :dl_type => 0x0800,
                                            :dl_dst => outside_hw, :nw_dst => outside_ip ),
                          :priority => 0x100,
                          :actions => [ Trema::ActionSetDlDst.new( :dl_dst => Trema::Mac.new(inside_hw) ),
                                        Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new(inside_ip) ),
                                        Trema::ActionOutput.new( :port => inside_port ) ] )

        send_flow_mod_add(datapath_id,
                          :match => inside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0800,
                                            :dl_src => inside_hw, :nw_src => inside_ip ) :
                          Trema::Match.new( :in_port => inside_port, :dl_type => 0x0800,
                                            :dl_src => inside_hw, :nw_src => inside_ip ),
                          :priority => 0x100,
                          :actions => [ Trema::ActionSetDlSrc.new( :dl_src => Trema::Mac.new(outside_hw) ),
                                        Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new(outside_ip) ),
                                        Trema::ActionOutput.new( :port => dest_outside_port ) ] )
      end
    end


    #
    # Event handler glue for Trema.
    #

    $fd_set = {}


    module EventFdConnection
      def initialize connection
        @connection = connection
      end

      def notify_readable
        @connection.notify_readable
      end

      def notify_writable
        @connection.notify_writable
      end

      def unbind
        # EM.next_tick do
        #   # socket is detached from the eventloop, but still open
        #   data = @io.read
        # end
      end  
    end


    class CustomEventHandler < Trema::EventHandler
      include Dcmgr::Logger

      def init_event_handler
        logger.info "Called CustomEventHandler init_event_handler."
      end

      def finalize_event_handler
        logger.info "Called CustomEventHandler finalize_event_handler."
      end

      def stop_event_handler
        logger.info "Called CustomEventHandler stop_event_handler."
        EM.stop
      end

      def run_event_handler_once
        logger.info "Called CustomEventHandler run_event_handler_once."
      end
      
      def set_fd_handler fd, connection
        logger.info "Called CustomEventHandler immediate set_fd_handler, #{fd}."
        
        $fd_set[ fd ] = EM.watch fd, EventFdConnection, connection
      end
      
      def delete_fd_handler fd
        logger.info "Called CustomEventHandler delete_fd_handler, #{fd}."
        connection = $fd_set[ fd ]
        $fd_set[ fd ] = nil

        connection.detach
      end

      def set_readable fd, state
        # logger.debug "Called CustomEventHandler set_readable, #{fd}."

        if fd < 0
          logger.error "Called set_readable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_readable = state
      end

      def set_writable fd, state
        # logger.debug "Called CustomEventHandler set_writable, #{fd}."

        if fd < 0
          logger.error "Called set_writable with negative fd: #{fd}, #{state}."
          return
        end

        $fd_set[ fd ].notify_writable = state
      end

      def readable fd
        logger.debug "Called CustomEventHandler readable, #{fd}."
      end

      def writable fd
        logger.debug "Called CustomEventHandler writable, #{fd}."
      end

    end

    
    class OpenFlowForwardingEntry
      attr_reader :mac
      attr_reader :port_no

      def initialize mac, port_no
        @mac = mac
        @port_no = port_no
      end

      def update port_no
        @port_no = port_no
      end
    end
      
    class OpenFlowForwardingDatabase
      def initialize
        @db = {}
      end

      def port_no_of mac
        dest = @db[mac]

        if dest
          dest.port_no
        else
          nil
        end
      end

      def learn mac, port_no
        entry = @db[mac]

        if entry
          entry.update port_no
        else
          @db[new_entry.mac] = ForwardingEntry.new(mac, port_no)
        end
      end
    end

  end
end
