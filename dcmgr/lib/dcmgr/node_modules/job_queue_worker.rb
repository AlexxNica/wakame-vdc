# -*- coding: utf-8 -*-

module Dcmgr
  module NodeModules
    class JobQueueWorker < Isono::NodeModules::Base
      include Dcmgr::Logger
      
      config_section do |c|
        desc "default job concurrency"
        c.concurrency = 1
      end

      initialize_hook do
        @worker_thread = Isono::ThreadPool.new(4)
        @max_attempts = 3
        @pollers = {}
      end

      attr_reader :worker_thread, :max_attempts

      def subscribe(queue_name, concurrency, &blk)
        return if @pollers.has_key?(queue_name)

        poller = @pollers[queue_name] = Poller.new(queue_name, concurrency, self, blk)
        # trigger initial polling.
        poller.start
      end

      def unsubscribe(queue_name)
        poller = @pollers.delete(queue_name)
        if poller
          poller.stop
        end
      end

      class Poller
        include Dcmgr::Logger

        class PollScheduler
          def initialize(poller)
            raise ArgumentError if !poller.is_a?(Poller)
            @poller = poller

            @polling_wait_sec = 5

            # handled in EM thread.
            @inflight_timers = []
          end

          def start
          end

          def stop
          end

          def wait
            EM.schedule {
              t = EM::Timer.new(@polling_wait_sec) {
                begin
                  @poller.poll
                ensure
                  @inflight_timers.delete(t)
                end
              }
            @inflight_timers << t
          }
          end
        end

        attr_reader :queue_name, :concurrency
        
        def initialize(queue_name, concurrency, worker, blk)
          raise ArgumentError if !worker.is_a?(JobQueueWorker)
          @queue_name = queue_name
          @concurrency = concurrency
          @worker = worker
          @block = blk
          @running = true

          # handled in EM thread.
          @inflight_timers = []
        end

        def start
          @concurrency.times {
            poll
          }
        end

        def stop
          @running = false
          EM.schedule {
            @inflight_timers.each(&:cancel)
          }
        end

        def running?
          @running
        end
        
        def poll
          @worker.worker_thread.pass do
            begin
              pop_once
            rescue ::Exception => e
              logger.error("Rescheduling queue pop after ?? seconds. Something went wrong.: #{e.message}")
              logger.error(e)
            ensure
              schedule_next
            end
          end
        end
        
        private
        
        def pop_once
          job = pop_job
          if job.nil?
            logger.debug("Rescheduling queue pop after ?? seconds. None of pending jobs found.")
          else
            begin
              run(job)
              Dcmgr::Messaging.job_queue.finish_success(job[:uuid])
              schedule_immediate
              logger.info("Finished Job successfully: #{job[:uuid]}")
            rescue ::Exception => e
              if job[:retry_count] < job[:retry_max]
                logger.info("Running Job Failed. Re-queueing. (retry current #{job[:retry_count]} < max #{job[:retry_max]}) : #{job[:uuid]}: #{e.message}")
              else
                logger.info("Running Job Failed. Giving up. (retry current #{job[:retry_count]} = max #{job[:retry_max]}): #{job[:uuid]}: #{e.message}")
              end
              Dcmgr::Messaging.job_queue.finish_fail(job[:uuid], e.message)
              raise
            end
          end
        end
        
        def pop_job
          attempts = 0
          job = nil
          begin
            job = Dcmgr::Messaging.job_queue.pop(@queue_name, @worker.node.node_id)
            if job
              logger.info("Found Job from #{@queue_name}: #{job[:uuid]}")
            else
              logger.debug("None of pending jobs found from #{@queue_name}.")
            end
          rescue => e
            attempts += 1
            if attempts <= @worker.max_attempts
              logger.error("Failed to pop queue from #{@queue_name}. Going to retry after ?? sec. [#{attempts} (current) <= #{@worker.max_attempts} (max)]")
              sleep(attempts ** 2)
              if @running
                retry
              else
                return nil
              end
            else
              logger.error("Give up to pop queue exceeds max_attemps retry count. #{@worker.max_attempts}")
            end
          end
          job
        end
        
        def run(job)
          logger.info("Starting Job: #{job[:uuid]}")
          begin
            Thread.current[:job]=job
            @block.arity > 0 ? @block.call(job) : @block.call
          ensure
            Thread.current[:job]=nil
          end
        end
        
        def schedule_next
          return if @running == false

          EM.schedule {
            t = EM::Timer.new(5) {
              begin
                poll
              ensure
                @inflight_timers.delete(t)
              end
            }
            @inflight_timers << t
          }
        end

        def schedule_immediate
          return if @running == false
          
          EM.schedule { poll }
        end

      end
    end
  end
end
