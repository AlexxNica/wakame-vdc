# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'eventmachine'
require 'trema'

module Dcmgr
  module NodeModules

    class OpenFlowController < Trema::Controller
      include Dcmgr::Logger

      def initialize service_openflow
        @service_openflow = service_openflow
        @ovs_ofctl = OvsOfctl.new
      end

      def start
        logger.info "OpenFlowController Thread Object Id: #{Thread.current}."
        logger.info "Instances db: #{self.name}, #{Trema::App[self.name]}."

        @fdb_incoming = OpenFlowForwardingDatabase.new
        @fdb_outgoing = OpenFlowForwardingDatabase.new
      end

      def print_foo
        logger.info "OpenFlowController #{Thread.current}: finished start."
      end

      def switch_ready datapath_id
        logger.info "switch_ready from %#x." % datapath_id
        logger.info "default gateway address: #{Isono::Util.default_gw_ipaddr}"

        # There's a short period of time between the switch being
        # activated and features_reply installing flow.
        send_message datapath_id, Trema::FeaturesRequest.new
      end

      def features_reply message
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "transaction_id: %#x" % message.transaction_id
        logger.info "n_buffers: %u" % message.n_buffers
        logger.info "n_tables: %u" % message.n_tables
        logger.info "capabilities: %u" % message.capabilities
        logger.info "actions: %u" % message.actions
        logger.info "ports: %s" % message.ports.collect { | each | each.number }.sort.join( ", " )

        message.ports.each do | each |
          if each.number == OFPP_LOCAL
            @local_hw = each.hw_addr
            logger.info "OFPP_LOCAL: hw_addr:#{@local_hw.to_s}"
          end
        end

        message.ports.each do | each |
          # logger.info "Found port: port:#{each.number} mac:#{each.hw_addr.to_s} name:#{each.name} config:#{each.config} "
          # "state:#{each.state} curr:#{each.curr} advertised:#{each.advertised} supported:#{each.supported} peer:#{each.peer}."

          # Need to look at the datalink address, not guess at numbers.
          #
          # TODO: Move handling of this into a dedicated function.
          if each.number == 1
            logger.info "ETH0 setting hw_addr = %s" % each.hw_addr.to_s

            # Don't allow packets from the network to reach the controller.
            send_flow_mod_add(message.datapath_id,
                              :match => Trema::Match.new( :in_port => each.number,
                                                          :dl_type => 0x0800, :nw_proto => 6,
                                                          :nw_dst => "169.254.169.254", :tp_dst => 80 ),
                              :priority => 2110 )

            # install_default_route message.datapath_id, each.number, OFPP_LOCAL

          elsif each.number > 1 and each.number < OFPP_MAX
            @service_openflow.port_status_map[ each.number ] = {
              :is_active => true
            }

            @service_openflow.add_instance each
          elsif each.number == OFPP_LOCAL
            # Also block 169.254?
          elsif each.number >= OFPP_MAX
          else

          end

        end

        # Send to controller all unmatched packets destined for the
        # meta-data server, and let the controller install the needed
        # flows.
        send_flow_mod_add(message.datapath_id,
                          :match => Trema::Match.new( :dl_type => 0x0800, :nw_proto => 6, :nw_dst => "169.254.169.254", :tp_dst => 80 ),
                          :priority => 2100,
                          :actions => Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) )

        # What other packets besides ARP uses broadcast? Catch them
        # all for logging purposes.
        # priority=0x1100,dl_dst=00:00:00:00:00:00,actions=controller
        send_flow_mod_add(message.datapath_id,
                          # :match => Trema::Match.new( :dl_dst => "00:00:00:00:00:00" ),
                          :match => Trema::Match.new( :dl_dst => "FF:FF:FF:FF:FF:FF" ),
                          :priority => 1002,
                          :actions => Trema::ActionOutput.new( :port => OFPP_FLOOD ) )

        # priority=0x1002,dl_dst=HOST_DL,actions=local
        send_flow_mod_add(message.datapath_id,
                          :match => Trema::Match.new( :dl_dst => @local_hw ),
                          :priority => 1002,
                          :actions => Trema::ActionOutput.new( :port => OFPP_LOCAL ) )

        # Currently just send all unknown dl_dst to the network,
        # however we need better routing here.
        send_flow_mod_add(message.datapath_id,
                          :match => Trema::Match.new( ),
                          :priority => 1000,
                          :actions => Trema::ActionOutput.new( :port => 1 ) )

        # priority=0x2000,arp,actions=controller

        # Since we use in-band communication, set it to drop unmatched
        # packets _AFTER_ setting up other flows.
        # send_flow_mod_add(message.datapath_id,
        #                   :match => Trema::Match.new( ),
        #                   :priority => 0,
        #                   :actions => [] )

        # Build the routing flow table and some other flows using
        # ovs-ofctl due to the lack of multiple tables support, which
        # was introduced in of-spec 1.1.

        # Flow tables for routing packets after without any filtering
        # or translation.
        
        #
        # Classification
        #
        @ovs_ofctl.add_flow "priority=#{3000},arp", "resubmit\\(,#{ 2}\\)"

        # MAC address based routing.
        @ovs_ofctl.add_flow "priority=#{1},table=#{10},dl_dst=FF:FF:FF:FF:FF:FF", "flood"
        @ovs_ofctl.add_flow "priority=#{1},table=#{10},dl_dst=#{@local_hw.to_s}", "local"
        @ovs_ofctl.add_flow "priority=#{0},table=#{10}", "output:1"

        #
        # ARP routing table
        #

        # ARP anti-spoofing flows.
        @ovs_ofctl.add_flow "priority=#{1},table=#{ 2},arp,in_port=#{1}", "resubmit\\(,#{12}\\)"
        @ovs_ofctl.add_flow "priority=#{1},table=#{ 2},arp,in_port=local", "resubmit\\(,#{12}\\)"
        @ovs_ofctl.add_flow "priority=#{0},table=#{ 2},arp", "drop"

        # TODO: How will this handle packets from host or eth0 that
        # spoof the mac of an instance?
        @ovs_ofctl.add_flow "priority=#{1},table=#{12},arp,dl_dst=FF:FF:FF:FF:FF:FF,arp_tha=00:00:00:00:00:00", "flood"
        @ovs_ofctl.add_flow "priority=#{1},table=#{12},arp,dl_dst=#{@local_hw.to_s}", "local"
        @ovs_ofctl.add_flow "priority=#{0},table=#{12},arp", "output:1"

      end

      def port_status message
        logger.info "port_status from %#x" % message.datapath_id
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "reason: #{message.reason}"
        logger.info "in_port: #{message.phy_port.number}"
        logger.info "hw_addr: #{message.phy_port.hw_addr}"
        logger.info "state: %#x" % message.phy_port.state

        case message.reason
        when OFPPR_ADD
          @service_openflow.port_status_map[ message.phy_port.number ] = {
            :is_active => true
          }

          @service_openflow.add_instance message.phy_port
        when OFPPR_DELETE
          @service_openflow.port_status_map[ message.phy_port.number ] = {
            :is_active => false
          }

          logger.info "Deleting port..."
        when OFPPR_MODIFY
          logger.info "Ignoring port modify..."
        end
      end

      def packet_in datapath_id, message
        # logger.info "Got a packet: datapath_id:%#x in_port:#{message.in_port}, macsa:#{message.macsa}, macda:#{message.macda}, port_no:." % datapath_id

        # Install DNAT route if we get a new connection destined for the
        # meta-data server.

        # We handle all ARP packets in the controller.
        if message.arp?
          # Also check the in_port...
          out_packet = Trema::PacketOut.from message

          if arp_translate_incoming_map.has_key? message.arp_tpa.to_s
            new_values = arp_translate_incoming_map[message.arp_tpa.to_s]
            out_packet.arp_tpa = Trema::IP.new( new_values[:nw_dst] ).to_i

          elsif arp_translate_outcoming_map.has_key? message.arp_spa.to_s
            new_values = arp_translate_outcoming_map[message.arp_spa.to_s]
            out_packet.arp_spa = Trema::IP.new( new_values[:nw_src] ).to_i

          else
            logger.info "No entries for ARP packet."
            return
          end

          # logger.info "Rewriting incoming ARP packet: #{message.arp_tpa.to_s} => nw_src:#{new_values[:nw_src]} nw_dst:#{new_values[:nw_dst]} output:#{new_values[:output]}."

          new_values[:output].each { | out_port |
            send_packet_out(datapath_id,
                            :data => out_packet.to_s,
                            :actions => Trema::ActionOutput.new( :port => out_port ) )
          }
          return
        end

        # Need to use ExactMatch due to lack of proper facilities for
        # inspecting packets.
        tmp_msg = Trema::ExactMatch.from( message )

        logger.info "Matching: %#x #{tmp_msg.nw_proto} #{Trema::IP.new( tmp_msg.nw_dst ).to_s} #{Trema::IP.new( tmp_msg.nw_src ).to_s} #{tmp_msg.tp_dst} #{tmp_msg.tp_src}." % tmp_msg.dl_type

        # Rewrite this after adding ip/tcp get functions to PacketIn.
        if tmp_msg.dl_type == 0x0800 and tmp_msg.nw_proto == 6 and
            Trema::IP.new( tmp_msg.nw_dst ).to_s == "169.254.169.254" and tmp_msg.tp_dst == 80
          install_dnat_entry datapath_id, tmp_msg, 0x2108, OFPP_LOCAL, @local_hw, Isono::Util.default_gw_ipaddr, 9002
          send_packet_out(datapath_id, :packet_in => message, :actions => Trema::ActionOutput.new( :port => OFPP_TABLE ) )
        end

      end

      def arp_translate_incoming_map
        @arp_translate_incoming_map ||= {}
      end

      def arp_translate_outcoming_map
        @arp_translate_outcoming_map ||= {}
      end

      #
      # Public functions
      #

      def install_default_route datapath_id, port_1, port_2
        logger.info "Installing default route between: port:#{port_1} <=> port:#{port_2}."
        
        send_flow_mod_add(datapath_id,
                          :match => Trema::Match.new( :in_port => port_1 ),
                          :priority => 1000,
                          :actions => Trema::ActionOutput.new( :port => port_2 ) )
        send_flow_mod_add(datapath_id,
                          :match => Trema::Match.new( :in_port => port_2 ),
                          :priority => 1000,
                          :actions => Trema::ActionOutput.new( :port => port_1 ) )
      end

      # TODO: Change the input message type to PacketIn.
      def install_dnat_entry datapath_id, message, priority, dest_port, dest_hw, dest_ip, dest_tp
        logger.info "Installing DNAT entry: #{dest_port} #{dest_hw} #{dest_ip}:#{dest_tp}"

        msg_nw_src = Trema::IP.new(message.nw_src).to_s
        msg_nw_dst = Trema::IP.new(message.nw_dst).to_s

        prefix = "priority=#{priority},table=#{ 0},idle_timeout=#{300},tcp"

        @ovs_ofctl.add_flow "#{prefix},#{@ovs_ofctl.arg_in_port message.in_port},dl_src=#{message.dl_src.to_s},dl_dst=#{message.dl_dst.to_s},nw_src=#{msg_nw_src},nw_dst=#{msg_nw_dst},tp_src=#{message.tp_src},tp_dst=#{message.tp_dst}", "mod_dl_dst:#{dest_hw},mod_nw_dst:#{dest_ip},mod_tp_dst:#{dest_tp},#{@ovs_ofctl.arg_output dest_port}"

        @ovs_ofctl.add_flow "#{prefix},#{@ovs_ofctl.arg_in_port dest_port},dl_src=#{dest_hw.to_s},dl_dst=#{message.dl_src.to_s},nw_src=#{dest_ip},nw_dst=#{msg_nw_src},tp_src=#{dest_tp},tp_dst=#{message.tp_src}", "mod_dl_src:#{message.dl_dst.to_s},mod_nw_src:#{msg_nw_dst},mod_tp_src:#{message.tp_dst},#{@ovs_ofctl.arg_output message.in_port}"

        # send_flow_mod_add(datapath_id,
        #                   :match => Trema::Match.new( :in_port => message.in_port, :dl_type => message.dl_type, :nw_proto => message.nw_proto,
        #                                               :dl_src => message.dl_src.to_s, :dl_dst => message.dl_dst.to_s,
        #                                               :nw_src => message.nw_src, :nw_dst => message.nw_dst,
        #                                               :tp_src => message.tp_src, :tp_dst => message.tp_dst ),
        #                   :priority => priority,
        #                   :idle_timeout => 300,
        #                   :actions => [ Trema::ActionSetDlDst.new( :dl_dst => dest_hw ),
        #                                 Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new( dest_ip ) ),
        #                                 Trema::ActionSetTpDst.new( :tp_dst => dest_tp ),
        #                                 Trema::ActionOutput.new( :port => dest_port ) ] )
        
        # send_flow_mod_add(datapath_id,
        #                   :match => Trema::Match.new( :in_port => dest_port, :dl_type => message.dl_type, :nw_proto => message.nw_proto,
        #                                               :dl_src => dest_hw.to_s, :dl_dst => message.dl_src.to_s,
        #                                               :nw_src => dest_ip, :nw_dst => message.nw_src,
        #                                               :tp_src => dest_tp, :tp_dst => message.tp_src ),
        #                   :priority => priority,
        #                   :idle_timeout => 300,
        #                   :actions => [ Trema::ActionSetDlSrc.new( :dl_src => message.dl_dst ),
        #                                 Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new( message.nw_dst ) ),
        #                                 Trema::ActionSetTpSrc.new( :tp_src => message.tp_dst ),
        #                                 Trema::ActionOutput.new( :port => message.in_port ) ] )
      end

      def install_snat_entry datapath_id, inside_port, inside_hw, inside_ip, outside_port, outside_hw, outside_ip
        # TODO: Verify that the outside_port is valid.

        #dest_inside_port = (inside_port == OFPP_ALL ? OFPP_NORMAL : inside_port)
        #dest_outside_port = (outside_port == OFPP_ALL ? OFPP_NORMAL : outside_port)

        logger.info "Installing StaticNAT entry: inside:'#{inside_port} #{inside_hw} #{inside_ip}' outside:'#{outside_port} #{outside_hw} #{outside_ip}'"

        # Currently we're using OFPP_TABLE to ensure modifications get
        # done and the packet gets sent for processing. We need to add
        # our own ARP table in order to route packets without this
        # hack.
        dest_outside_port = outside_port == OFPP_NORMAL ? OFPP_TABLE : outside_port;

        # Translate ARP packets.
        send_flow_mod_add(datapath_id,
                          :match => outside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0806, :nw_dst => outside_ip ) :
                          Trema::Match.new( :in_port => outside_port, :dl_type => 0x0806, :nw_dst => outside_ip ),
                          :priority => 100,
                          :actions => [ # Trema::ActionSetDlDst.new( :dl_dst => Trema::Mac.new(inside_hw) ),
                                        # Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new(inside_ip) ),
                                        Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) ] )
        send_flow_mod_add(datapath_id,
                          :match => inside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0806,
                                            :dl_src => inside_hw, :nw_src => inside_ip ) :
                          Trema::Match.new( :in_port => inside_port, :dl_type => 0x0806,
                                            :dl_src => inside_hw, :nw_src => inside_ip ),
                          :priority => 100,
                          :actions => [ # Trema::ActionSetDlSrc.new( :dl_src => Trema::Mac.new(outside_hw) ),
                                        # Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new(outside_ip) ),
                                        Trema::ActionOutput.new( :port => OFPP_CONTROLLER ) ] )

        # Hack that is not really safe.
        arp_translate_incoming_map[outside_ip] = { :nw_dst => inside_ip, :output => [ inside_port ] }
        arp_translate_outcoming_map[inside_ip] = { :nw_src => outside_ip, :output => [ OFPP_LOCAL, 1 ] }

        # Translate IP packets.
        send_flow_mod_add(datapath_id,
                          :match => outside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0800,
                                            :dl_dst => outside_hw, :nw_dst => outside_ip ) :
                          Trema::Match.new( :in_port => outside_port, :dl_type => 0x0800,
                                            :dl_dst => outside_hw, :nw_dst => outside_ip ),
                          :priority => 100,
                          :actions => [ Trema::ActionSetDlDst.new( :dl_dst => Trema::Mac.new(inside_hw) ),
                                        Trema::ActionSetNwDst.new( :nw_dst => Trema::IP.new(inside_ip) ),
                                        Trema::ActionOutput.new( :port => inside_port ) ] )

        send_flow_mod_add(datapath_id,
                          :match => inside_port == OFPP_NORMAL ?
                          Trema::Match.new( :dl_type => 0x0800,
                                            :dl_src => inside_hw, :nw_src => inside_ip ) :
                          Trema::Match.new( :in_port => inside_port, :dl_type => 0x0800,
                                            :dl_src => inside_hw, :nw_src => inside_ip ),
                          :priority => 100,
                          :actions => [ Trema::ActionSetDlSrc.new( :dl_src => Trema::Mac.new(outside_hw) ),
                                        Trema::ActionSetNwSrc.new( :nw_src => Trema::IP.new(outside_ip) ),
                                        Trema::ActionOutput.new( :port => dest_outside_port ) ] )
      end

      def install_route port, hw, ip
        # Replace...
        @ovs_ofctl.add_flow "priority=#{1002},table=#{0},dl_dst=#{hw}", "output:#{port}"

        # MAC address based routing to instance.

        @ovs_ofctl.add_flow "priority=#{1},table=#{11},dl_dst=#{hw}", "output:#{port}"
      end

      def install_arp_antispoof port, hw, ip
        # Require correct ARP source IP/MAC from instance, and protect the instance IP from ARP spoofing.
        @ovs_ofctl.add_flow "priority=#{3},table=#{ 2},arp,in_port=#{port},arp_sha=#{hw},nw_src=#{ip}", "resubmit\\(,#{12}\\)"
        @ovs_ofctl.add_flow "priority=#{2},table=#{ 2},arp,nw_src=#{ip}", "drop"

        # Routing of ARP packets to instance.
        @ovs_ofctl.add_flow "priority=#{2},table=#{12},arp,dl_dst=#{hw},nw_dst=#{ip}", "output:#{port}"
      end

    end


    class OvsOfctl
      include Dcmgr::Logger
      attr_accessor :ovs_ofctl

      def initialize
        @ovs_ofctl = "/usr/share/axsh/wakame-vdc/ovs/bin/ovs-ofctl"
      end

      def add_flow flow_match, actions
        command = "#{@ovs_ofctl} add-flow br0 #{flow_match},actions=#{actions}"

        logger.info "Calling: '#{command}' => #{system(command)}."
      end

      def arg_in_port port_number
        case port_number
        when OpenFlowController::OFPP_LOCAL
          return "in_port=local"
        else
          return "in_port=#{port_number}" if port_number < OpenFlowController::OFPP_MAX
        end
      end

      def arg_output port_number
        case port_number
        when OpenFlowController::OFPP_LOCAL
          return "local"
        else
          return "output:#{port_number}" if port_number < OpenFlowController::OFPP_MAX
        end
      end
    end


    class OpenFlowForwardingEntry
      attr_reader :mac
      attr_reader :port_no

      def initialize mac, port_no
        @mac = mac
        @port_no = port_no
      end

      def update port_no
        @port_no = port_no
      end
    end
      
    class OpenFlowForwardingDatabase
      def initialize
        @db = {}
      end

      def port_no_of mac
        dest = @db[mac]

        if dest
          dest.port_no
        else
          nil
        end
      end

      def learn mac, port_no
        entry = @db[mac]

        if entry
          entry.update port_no
        else
          @db[new_entry.mac] = ForwardingEntry.new(mac, port_no)
        end
      end
    end

  end
end
