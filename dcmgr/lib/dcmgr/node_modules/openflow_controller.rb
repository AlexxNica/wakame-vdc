# -*- coding: utf-8 -*-
$LOAD_PATH.unshift File.expand_path('../../../../../trema/ruby', __FILE__)

require 'eventmachine'
require 'trema'

module Dcmgr
  module NodeModules

    class OpenFlowController < Trema::Controller
      include Dcmgr::Logger

      attr_reader :ports

      @@group_outgoing_table = 2
      @@group_incoming_table = 3
      @@group_load_port_table = 4
      @@group_load_outgoing_table = 5

      # Re-number these...
      @@arp_antispoof_table = 10
      @@arp_route_table = 11
      @@metadata_outgoing_table = 12
      @@metadata_incoming_table = 13

      @@mac_route_table = 14

      def initialize service_openflow
        @ports = {}
        @service_openflow = service_openflow
        @ovs_ofctl = OvsOfctl.new service_openflow.node.manifest.config
      end

      def start
        logger.info "OpenFlowController Thread Object Id: #{Thread.current}."
        logger.info "Instances db: #{self.name}, #{Trema::App[self.name]}."
      end

      def switch_ready datapath_id
        logger.info "switch_ready from %#x." % datapath_id
        logger.info "default gateway address: #{Isono::Util.default_gw_ipaddr}"

        # There's a short period of time between the switch being
        # activated and features_reply installing flow.
        send_message datapath_id, Trema::FeaturesRequest.new
      end

      def features_reply message
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "transaction_id: %#x" % message.transaction_id
        logger.info "n_buffers: %u" % message.n_buffers
        logger.info "n_tables: %u" % message.n_tables
        logger.info "capabilities: %u" % message.capabilities
        logger.info "actions: %u" % message.actions
        logger.info "ports: %s" % message.ports.collect { | each | each.number }.sort.join( ", " )

        message.ports.each do | each |
          if each.number == OFPP_LOCAL
            @local_hw = each.hw_addr
            logger.info "OFPP_LOCAL: hw_addr:#{@local_hw.to_s}"
          end
        end

        message.ports.each do | each |
          # Need to look at the datalink address, not guess at numbers.
          #
          # TODO: Move handling of this into a dedicated function.

          ports[each.number] = OpenFlowPort.new(each)

          @service_openflow.add_instance ports[each.number] if each.name =~ /^vif-/
        end

        # Build the routing flow table and some other flows using
        # ovs-ofctl due to the lack of multiple tables support, which
        # was introduced in of-spec 1.1.

        # Flow tables for routing packets after without any filtering
        # or translation.
        
        #
        # Classification
        #
        @ovs_ofctl.add_flow "priority=#{3},arp", "resubmit\\(,#{@@arp_antispoof_table}\\)"

        @ovs_ofctl.add_flow "priority=#{2},in_port=#{1}",  "resubmit\\(,#{@@group_incoming_table}\\)"
        @ovs_ofctl.add_flow "priority=#{2},in_port=local", "resubmit\\(,#{@@group_incoming_table}\\)"
        # @ovs_ofctl.add_flow "priority=#{1}",               "resubmit\\(,#{@@group_outgoing_table}\\)"
        @ovs_ofctl.add_flow "priority=#{1}",               "resubmit\\(,#{@@group_load_port_table}\\)"

        # Temporarily allow all ssh connections;
        @ovs_ofctl.add_flow "priority=#{4},tcp,tp_src=22", "resubmit\\(,#{@@mac_route_table}\\)"
        @ovs_ofctl.add_flow "priority=#{4},tcp,tp_dst=22", "resubmit\\(,#{@@mac_route_table}\\)"

        #
        # MAC address routing
        #

        # Unprotected flows.
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@mac_route_table},dl_dst=FF:FF:FF:FF:FF:FF", "flood"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@mac_route_table},dl_dst=#{@local_hw.to_s}", "local"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@mac_route_table}", "output:#{1}"

        # Protected flows.
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_incoming_table},dl_dst=FF:FF:FF:FF:FF:FF", "flood"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_incoming_table},dl_dst=#{@local_hw.to_s}", "local"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@group_incoming_table}", "output:#{1}"

        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_load_port_table},dl_dst=FF:FF:FF:FF:FF:FF", "load:#{OFPP_FLOOD}-\\>NXM_NX_REG0\\[\\],resubmit\\(,#{@@group_load_outgoing_table}\\)"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_load_port_table},dl_dst=#{@local_hw.to_s}", "load:#{OFPP_LOCAL}-\\>NXM_NX_REG0\\[\\],resubmit\\(,#{@@group_load_outgoing_table}\\)"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@group_load_port_table}", "load:#{1}-\\>NXM_NX_REG0\\[\\],resubmit\\(,#{@@group_load_outgoing_table}\\)"

        @ovs_ofctl.add_flow "priority=#{0},table=#{@@group_load_outgoing_table}", "output:NXM_NX_REG0[]"

        #
        # ARP routing table
        #

        # ARP anti-spoofing flows.
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@arp_antispoof_table},arp,in_port=#{1}", "resubmit\\(,#{@@arp_route_table}\\)"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@arp_antispoof_table},arp,in_port=local", "resubmit\\(,#{@@arp_route_table}\\)"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@arp_antispoof_table},arp", "drop"

        # TODO: How will this handle packets from host or eth0 that
        # spoof the mac of an instance?
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@arp_route_table},arp,dl_dst=FF:FF:FF:FF:FF:FF,arp_tha=00:00:00:00:00:00", "flood"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@arp_route_table},arp,dl_dst=#{@local_hw.to_s}", "local"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@arp_route_table},arp", "output:#{1}"

        #
        # Meta-data connections
        #
        @ovs_ofctl.add_flow "priority=#{3},tcp,nw_dst=169.254.169.254,tp_dst=80", "resubmit\\(,#{@@metadata_outgoing_table}\\)"
        @ovs_ofctl.add_flow "priority=#{3},tcp,nw_src=#{Isono::Util.default_gw_ipaddr},tp_src=#{9002}", "resubmit\\(,#{@@metadata_incoming_table}\\)"

        @ovs_ofctl.add_flow "priority=#{4},table=#{@@metadata_outgoing_table},in_port=#{1}", "drop"
        @ovs_ofctl.add_flow "priority=#{4},table=#{@@metadata_outgoing_table},in_port=local", "drop"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@metadata_outgoing_table}", "controller"

        # We should route normally when not matched.
        @ovs_ofctl.add_flow "priority=#{4},table=#{@@metadata_incoming_table},tcp,in_port=#{1}", "drop"
        @ovs_ofctl.add_flow "priority=#{0},table=#{@@metadata_incoming_table},tcp", "drop"

      end

      def port_status message
        logger.info "port_status from %#x" % message.datapath_id
        logger.info "datapath_id: %#x" % message.datapath_id
        logger.info "reason: #{message.reason}"
        logger.info "in_port: #{message.phy_port.number}"
        logger.info "hw_addr: #{message.phy_port.hw_addr}"
        logger.info "state: %#x" % message.phy_port.state

        case message.reason
        when OFPPR_ADD
          logger.info "Adding instance port: port:#{message.phy_port.number}."
          raise "OpenFlowPort" if ports.has_key? message.phy_port.number

          ports[message.phy_port.number] = OpenFlowPort.new(message.phy_port)

          @service_openflow.add_instance ports[message.phy_port.number] if message.phy_port.name =~ /^vif-/

        when OFPPR_DELETE
          logger.info "Deleting instance port: port:#{message.phy_port.number}."
          raise "UnknownOpenflowPort" if not ports.has_key? message.phy_port.number

          ports.delete ports[message.phy_port.number]

        when OFPPR_MODIFY
          logger.info "Ignoring port modify..."
        end
      end

      def packet_in datapath_id, message
        if message.arp?
          logger.info "Got ARP packet; source:#{message.arp_sha.to_s}:#{message.arp_spa.to_s} dest:#{message.arp_tha.to_s}:#{message.arp_tpa.to_s}."
          return
        end

        if message.ipv4? and message.tcp?
          logger.info "Got IPv4/TCP packet; source:#{message.ipv4_saddr.to_s}:#{message.tcp_src_port} dest:#{message.ipv4_daddr.to_s}:#{message.tcp_dst_port}."

          # Add dynamic NAT flows for meta-data connections.
          if message.ipv4_daddr.to_s == "169.254.169.254" and message.tcp_dst_port == 80
            install_dnat_entry datapath_id, message, @@metadata_outgoing_table, @@metadata_incoming_table, OFPP_LOCAL, @local_hw, Isono::Util.default_gw_ipaddr, 9002
            send_packet_out(datapath_id, :packet_in => message, :actions => Trema::ActionOutput.new( :port => OFPP_TABLE ) )
            return
          end

        end

      end

      #
      # Public functions
      #

      def install_dnat_entry datapath_id, message, outgoing_table, incoming_table, dest_port, dest_hw, dest_ip, dest_tp
        logger.info "Installing DNAT entry: #{dest_port} #{dest_hw} #{dest_ip}:#{dest_tp}"

        msg_nw_src = message.ipv4_saddr.to_s
        msg_nw_dst = message.ipv4_daddr.to_s

        # We don't need to match against the IP or port used by the
        # classifier to pass the flow to these tables.

        prefix = "priority=3,idle_timeout=#{300},tcp"

        prefix_outgoing = "#{prefix},table=#{outgoing_table},#{@ovs_ofctl.arg_in_port message.in_port}"
        # classifier_outgoing = "nw_dst=#{msg_nw_dst},tp_dst=#{message.tcp_dst_port}"
        match_outgoing = "dl_src=#{message.macsa.to_s},dl_dst=#{message.macda.to_s},nw_src=#{msg_nw_src},tp_src=#{message.tcp_src_port}"
        action_outgoing = "mod_dl_dst:#{dest_hw},mod_nw_dst:#{dest_ip},mod_tp_dst:#{dest_tp},#{@ovs_ofctl.arg_output dest_port}"

        prefix_incoming = "#{prefix},table=#{incoming_table},#{@ovs_ofctl.arg_in_port dest_port}"
        # classifier_incoming = "nw_src=#{dest_ip},tp_src=#{dest_tp}"
        match_incoming = "dl_src=#{dest_hw.to_s},dl_dst=#{message.macsa.to_s},nw_dst=#{msg_nw_src},tp_dst=#{message.tcp_src_port}"
        action_incoming = "mod_dl_src:#{message.macda.to_s},mod_nw_src:#{msg_nw_dst},mod_tp_src:#{message.tcp_dst_port},#{@ovs_ofctl.arg_output message.in_port}"

        @ovs_ofctl.add_flow "#{prefix_outgoing},#{match_outgoing}", action_outgoing
        @ovs_ofctl.add_flow "#{prefix_incoming},#{match_incoming}", action_incoming
      end

      def install_route port, hw, ip
        # MAC address based routing to instance.
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@mac_route_table},dl_dst=#{hw}", "output:#{port}"

        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_incoming_table},dl_dst=#{hw}", "drop"
        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_outgoing_table},dl_dst=#{hw}", "drop"

        @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_load_port_table},dl_dst=#{hw}", "load:#{port}-\\>NXM_NX_REG0\\[\\],resubmit\\(,#{@@group_load_outgoing_table}\\)"
      end

      def remove_route port, hw, ip
        # MAC address based routing to instance.
        @ovs_ofctl.del_flow "table=#{@@mac_route_table},dl_dst=#{hw}"

        @ovs_ofctl.del_flow "table=#{@@group_outgoing_table},dl_dst=#{hw}"
      end

      def install_arp_antispoof port, hw, ip
        # Require correct ARP source IP/MAC from instance, and protect the instance IP from ARP spoofing.
        @ovs_ofctl.add_flow "priority=#{3},table=#{@@arp_antispoof_table},arp,in_port=#{port},arp_sha=#{hw},nw_src=#{ip}", "resubmit\\(,#{@@arp_route_table}\\)"
        @ovs_ofctl.add_flow "priority=#{2},table=#{@@arp_antispoof_table},arp,nw_src=#{ip}", "drop"

        # Routing of ARP packets to instance.
        @ovs_ofctl.add_flow "priority=#{2},table=#{@@arp_route_table},arp,dl_dst=#{hw},nw_dst=#{ip}", "output:#{port}"
      end

      def remove_arp_antispoof port, hw, ip
        # Require correct ARP source IP/MAC from instance, and protect the instance IP from ARP spoofing.
        @ovs_ofctl.del_flow "table=#{@@arp_antispoof_table},arp,in_port=#{port},arp_sha=#{hw},nw_src=#{ip}"
        @ovs_ofctl.del_flow "table=#{@@arp_antispoof_table},arp,nw_src=#{ip}"

        # Routing of ARP packets to instance.
        @ovs_ofctl.del_flow "table=#{@@arp_route_table},arp,dl_dst=#{hw},nw_dst=#{ip}"
      end

      def install_icmp port, hw, ip, icmp_type, icmp_code
        match_type = "dl_type=0x0800,nw_proto=1"

        if icmp_type != -1 && icmp_code != -1
          match_type += ",icmp_type=#{icmp_type},icmp_code=#{icmp_code}"
        end

        # Force learning of icmp_type/code.
        
        # Use the exact icmp type match for learned flows?

        # learn_outgoing_match = "priority=#{2},table=#{@@group_outgoing_table},#{match_type},NXM_OF_IN_PORT[],NXM_OF_ETH_SRC[],NXM_OF_ETH_DST[],NXM_OF_IP_SRC[],NXM_OF_IP_DST[]"
        # learn_outgoing_actions = "resubmit\\(,#{@@group_incoming_table}\\)"

        # learn_incoming_match = "priority=#{2},table=#{@@group_incoming_table},#{match_type},NXM_OF_ETH_SRC[]=NXM_OF_ETH_DST[],NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],NXM_OF_IP_SRC[]=NXM_OF_IP_DST[],NXM_OF_IP_DST[]=NXM_OF_IP_SRC[]"
        # learn_incoming_actions = "output:NXM_OF_IN_PORT[]"

        # # Consider resubmitting to group_incoming_table?
        # @ovs_ofctl.add_flow "priority=#{1},table=#{@@group_outgoing_table},#{match_type},dl_src=#{hw},nw_src=#{ip}", "learn\\(#{learn_outgoing_match},#{learn_outgoing_actions}\\),learn\\(#{learn_incoming_match},#{learn_incoming_actions}\\),resubmit\\(,#{@@group_outgoing_table}\\)"
      end

    end


    class OvsOfctl
      include Dcmgr::Logger
      attr_accessor :ovs_ofctl

      def initialize config
        @ovs_ofctl = config.ovs_ofctl_path
        @switch = config.bridge_novlan
      end

      def add_flow flow_match, actions
        command = "#{@ovs_ofctl} add-flow #{@switch} #{flow_match},actions=#{actions}"
        logger.info "'#{command}' => #{system(command)}."
      end

      def del_flow flow_match
        command = "#{@ovs_ofctl} del-flows #{@switch} #{flow_match}"
        logger.info "'#{command}' => #{system(command)}."
      end

      def arg_in_port port_number
        case port_number
        when OpenFlowController::OFPP_LOCAL
          return "in_port=local"
        else
          return "in_port=#{port_number}" if port_number < OpenFlowController::OFPP_MAX
        end
      end

      def arg_output port_number
        case port_number
        when OpenFlowController::OFPP_LOCAL
          return "local"
        else
          return "output:#{port_number}" if port_number < OpenFlowController::OFPP_MAX
        end
      end
    end

    class OpenFlowPort
      attr_reader :port_info
      attr_accessor :has_instance
      attr_accessor :ip
      attr_accessor :mac

      def initialize port_info
        @port_info = port_info
        @has_instance = false
        @ip = nil
        @mac = nil
      end
    end

    class OpenFlowForwardingEntry
      attr_reader :mac
      attr_reader :port_no

      def initialize mac, port_no
        @mac = mac
        @port_no = port_no
      end

      def update port_no
        @port_no = port_no
      end
    end
      
    class OpenFlowForwardingDatabase
      def initialize
        @db = {}
      end

      def port_no_of mac
        dest = @db[mac]

        if dest
          dest.port_no
        else
          nil
        end
      end

      def learn mac, port_no
        entry = @db[mac]

        if entry
          entry.update port_no
        else
          @db[new_entry.mac] = ForwardingEntry.new(mac, port_no)
        end
      end
    end

  end
end
