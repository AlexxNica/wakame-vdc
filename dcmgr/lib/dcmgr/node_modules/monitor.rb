# -*- coding: utf-8 -*-
require 'metric_libs'

module Dcmgr
  module NodeModules
    class Monitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers

      initialize_hook do
        EM.defer do
          myinstance.initialize_alarm_from_database
        end

        @alarm_manager = AlarmManager.new(EmTimer.new)
        @resource_capture = ResourceCapture.new(node)

        logger.info("Resource monitor start")
        EM.add_periodic_timer(5) do
          EM.defer do
            resources = @resource_capture.get_resources
            @alarm_manager.update_resources(resources)
          end
        end

        job = Isono::NodeModules::JobChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job.register_endpoint("resource-alarm-registry.#{node.node_id}",
          Isono::Rack.build do
            run proc {|req, res|
              app.call(req, res)
            }
          end)
      end

      terminate_hook do
      end

      def update_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        EM.next_tick do
          @alarm_manager.update(alm)
        end
      end

      def delete_alarm(alarm_id)
        alm = get_alarm(alarm_id)
        EM.next_tick do
          @alarm_manager.delete(alm)
        end
      end

      def get_alarm(alm_id)
        raise ArgumentError unless alm_id.is_a?(String)
        rpc.request('alarm-collector', 'get_alarm', alm_id)
      end

      def initialize_alarm_from_database
        logger.info("Initialize alarm from database")
        # TODO: add volume and network vif
        instance_ids = rpc.request('hva-collector', 'get_metric_monitor_instance_ids', node.node_id)
        alarms = rpc.request('alarm-collector', 'get_resource_alarms', instance_ids)
        @alarm_manager.updates(alarms)
      end

      private
      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

    end

    class EmTimer
      def cancel
        @timer.cancel
      end

      def add_periodic_timer(alm)
        @timer = EM::PeriodicTimer.new(alm.instance_variable_get(:@evaluation_periods)) do
          if alm.evaluate
            # TODO: Notification.
          end
        end
      end
    end

    class AlarmManager
      include Dcmgr::Logger

      def initialize(timer)
        @timer = timer
        # @manager = {:alarm_id => {:timer => @timer, :alarm => Alarm.new}
        @manager = {}
      end

      def update(alm)
        logger.info("Update alarm: #{alm}")
        if alm[:enabled]
          if get_hash(alm[:uuid])
            cancel_update_alarm(alm)
          else
            create_alarm(alm)
          end
        else
          delete_alarm(alm[:uuid])
        end
      end

      def updates(alms)
        raise ArgumentError unless alms.is_a?(Array)
        alms.each {|alm|
          update(alm)
        }
      end

      def delete(alm)
        logger.info("Remove alarm: #{alm}")
        delete_alarm(alm[:uuid])
      end

      def deletes(alms)
        raise ArgumentError unless alms.is_a?(Array)
        alms.each {|alm|
          delete(alm)
        }
      end

      def update_resources(resources)
        raise ArgumentError unless resources.is_a?(Hash)
        @manager.each_value {|alm|
          alm[:alarm].feed(resources)
        }
      end

      private
      def get_hash(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager[uuid]
      end

      def get_alarm(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager[uuid][:alarm]
      end

      def get_timer(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager[uuid][:timer]
      end

      def set_hash(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager[uuid] ||= {}
      end

      def set_alarm(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        @manager[alm[:uuid]][:alarm] = Alarm.new(alm, self)
      end

      def set_timer(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager[uuid][:timer] = @timer.add_periodic_timer(get_alarm(uuid))
      end

      def delete_hash(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        @manager.delete(uuid)
      end

      def cancel_update_alarm(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        logger.debug("Reset evaluation timer: #{alm[:uuid]} #{alm[:metric_name]}")
        get_timer(alm[:uuid]).cancel
        get_alarm(alm[:uuid]).update(alm)
        set_timer(alm[:uuid])
      end

      def create_alarm(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        logger.debug("Set evaluation timer: #{alm[:uuid]} #{alm[:metric_name]}")
        set_hash(alm[:uuid])
        set_alarm(alm)
        set_timer(alm[:uuid])
      end

      def delete_alarm(uuid)
        raise ArgumentError unless uuid.is_a?(String)
        logger.debug("Remove evaluation timer: #{uuid}")
        if get_hash(uuid)
          get_timer(uuid).cancel
          delete_hash(uuid)
        end
      end

    end

    class Alarm
      include Dcmgr::Logger
      include Dcmgr::Constants::Alarm

      def initialize(alm, manager)
        set_variable(alm)
        @manager = manager
        @resource = MetricLibs::TimeSeries.new
      end

      def update(alm)
        set_variable(alm)
      end

      def feed(data)
        raise ArgumentError unless data.is_a?(Hash)
        metric_name = @metric_name.split('.')
        @resource.push(data[@resource_id][metric_name[0]][metric_name[1]],
          Time.at(data[@resource_id][metric_name[0]]["time"].to_i))
      end

      def evaluate
        logger.info("Evaluation: #{@metric_name} #{@uuid}")
        logger.debug(@resource.dump)
        time = Time.now
        ev = case @metric_name
             when 'cpu.usage'
               end_time = time.to_i
               start_time = end_time - @evaluation_periods
               values = @resource.find(Time.at(start_time), Time.at(end_time)).map {|v|
                 v.value
               }
               usage = values.inject{|sum, n| sum.to_f + n.to_f} / values.size
               usage.method(SUPPORT_COMPARISON_OPERATOR[@params["comparison_operator"]]).call(@params["threshold"])
             when 'memory.usage'
               memory_usage = @resource.last.value.to_f
               memory_usage.method(SUPPORT_COMPARISON_OPERATOR[@params["comparison_operator"]]).call(@params["threshold"])
             else
               raise "Unknown metric name: #{@metric_name}"
             end

        delete_resource(time)
        ev
      end

      private
      def set_variable(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        alm.each {|k, v| instance_variable_set("@#{k}", v) }
      end

      def delete_resource(time)
        raise ArgumentError unless time.is_a?(Time)
        @resource.delete_all_since_at(time)
      end
    end

    class ResourceCapture
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper

      SUPPORT_METRIC_NAMES = {
        "cpu" => ['time', 'pid', 'usr_usage', 'system_usage', 'guest_usage', 'usage', 'cpu_number', 'cswch', 'nvcswch', 'usr_ms', 'system_ms', 'guest_ms'],
        "memory" => ['time', 'pid', 'minflt', 'majflt', 'vsz', 'rss', 'usage', 'minflt-nr', 'majflt-nr']
      }.freeze

      def initialize(node)
        @node = node
        @rpc = Isono::NodeModules::RpcChannel.new(@node)
      end

      def get_resources
        # TODO: add volume and network vif
        instlst = @rpc.request('hva-collector', 'get_instance_monitor_data', @node.node_id)

        h = {}
        instlst.each {|i|
          begin
            h["#{i[:uuid]}"] = {}

            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            raise "Unable to find the pid file: #{i[:uuid]}" unless File.exists?(pidfile)
            logger.debug("Find pidfile: #{pidfile}")

            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")

            cpu = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["cpu"] = parse_pidstat("cpu", cpu)

            memory = sh("pidstat -h -r -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["memory"] = parse_pidstat("memory", memory)

            logger.debug(h)

          rescue Exception => e
            logger.error("Error occured. [Instance ID: #{i[:uuid]}]")
            logger.error(e)
          end
        }
        h
      end

      private
      def parse_pidstat(metric_name, data)
        raise ArgumentError unless metric_name.is_a?(String)
        raise ArgumentError unless data.is_a?(Hash)

        metric = data[:stdout].split(/\n/)
        metric.shift

        initial_keys = SUPPORT_METRIC_NAMES[metric_name]
        raise "Unknown Metric type: #{metric_name}" if initial_keys.nil?
        
        values = []
        metric.each {|m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          m.pop
          next if m.include?("#")
          values << m
        }
        Hash[*initial_keys.zip(values.flatten.uniq).flatten]
      end

    end

    class Notification
      def initialize
      end
    end

  end
end
