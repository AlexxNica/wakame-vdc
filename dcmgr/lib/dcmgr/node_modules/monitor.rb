# -*- coding: utf-8 -*-
require 'metric_libs'

module Dcmgr
  module NodeModules
    class Monitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers

      initialize_hook do
        @alarm_manager = AlarmManager.new(node)
        @resource_capture = ResourceCapture.new(node)

        logger.info("Resource monitor start")
        EM.add_periodic_timer(5) do
          EM.defer do
            resources = @resource_capture.get_resources
            @alarm_manager.update_resources(resources)
          end
        end

        job = Isono::NodeModules::JobChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job.register_endpoint("resource-alarm-registry.#{node.node_id}",
          Isono::Rack.build do
            run proc {|req, res|
              app.call(req, res)
            }
          end)
      end

      terminate_hook do
      end

      def update_alarm(alarm_id)
        @alarm_manager.update_alarm(alarm_id)
      end

      def delete_alarm(alarm_id)
        @alarm_manager.delete_alarm(alarm_id)
      end

      private
      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

    end

    class AlarmManager
      include Dcmgr::Logger

      def initialize(node)
        @node = node
        @rpc = Isono::NodeModules::RpcChannel.new(@node)
        # @manager = {:alarm_id => {:timer => EM::PeriodicTimer.new, :data => Alarm.new}
        @manager = {}
        initialize_alarm_data
      end

      def update_alarm(alm_id)
        logger.info("Update alarm: #{alm_id}")
        alm = get_alarm(alm_id)
        if alm[:enabled]
          if @manager[alm[:uuid]]
            logger.debug("Reset evaluation timer: #{alm[:uuid]} #{alm[:metric_name]}")
            EM.next_tick do
              @manager[alm[:uuid]][:timer].cancel
              @manager[alm[:uuid]][:data].update(alm)
              @manager[alm[:uuid]][:timer] = add_resource_timer(alm)
            end
          else
            logger.debug("Set evaluation timer: #{alm[:uuid]} #{alm[:metric_name]}")
            EM.next_tick do
              @manager[alm[:uuid]] ||= {}
              @manager[alm[:uuid]][:data] = Alarm.new(alm)
              @manager[alm[:uuid]][:timer] = add_resource_timer(alm)
            end
          end
        else
          logger.debug("Remove evaluation timer: #{alm[:uuid]} #{alm[:metric_name]}")
          EM.next_tick do
            @manager[alm[:uuid]][:timer].cancel
            @manager.delete(alm[:uuid])
          end
        end
      end
      
      def delete_alarm(alm_id)
        logger.info("Remove alarm: #{alm_id}")
        alm = get_alarm(alm_id)
        if alm[:enabled] && @manager[alm[:uuid]]
          EM.next_tick do
            @manager[alm[:uuid]][:timer].cancel
            @manager.delete(alm[:uuid])
          end
        end
      end

      def update_resources(resources)
        raise ArgumentError unless resources.is_a?(Hash)
        @manager.each_value {|alm|
          alm[:data].feed(resources)
        }
      end

      private
      def initialize_alarm_data
        EM.defer do
          logger.info("Initialize alarm from database")
          # TODO: add volume and network vif
          instance_ids = @rpc.request('hva-collector', 'get_metric_monitor_instance_ids', @node.node_id)
          alarms = @rpc.request('alarm-collector', 'get_resource_alarms', instance_ids)
          alarms.each {|alm|
            @manager[alm[:uuid]] ||= {}
            @manager[alm[:uuid]][:data] = Alarm.new(alm)
            @manager[alm[:uuid]][:timer] = add_resource_timer(alm)
          }
        end
      end

      def get_alarm(alm_id)
        raise ArgumentError unless alm_id.is_a?(String)
        @rpc.request('alarm-collector', 'get_alarm', alm_id)
      end

      def add_resource_timer(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        EM::PeriodicTimer.new(alm[:evaluation_periods]) do
          if @manager[alm[:uuid]][:data].evaluate
            # TODO: Notification.
          end
        end
      end

    end

    class Alarm
      include Dcmgr::Logger
      include Dcmgr::Constants::Alarm

      def initialize(alm)
        set_variable(alm)
        @resource = MetricLibs::TimeSeries.new
      end

      def update(alm)
        set_variable(alm)
      end

      def feed(data)
        raise ArgumentError unless data.is_a?(Hash)
        metric_name = @metric_name.split('.')
        @resource.push(data[@resource_id][metric_name[0]][metric_name[1]],
          Time.at(data[@resource_id][metric_name[0]]["time"].to_i))
      end

      def evaluate
        logger.info("Evaluation: #{@metric_name} #{@uuid}")
        logger.debug(@resource.dump)
        case @metric_name
        when 'cpu.usage'
          time = Time.now
          end_time = time.to_i
          start_time = end_time - @evaluation_periods
          values = @resource.find(Time.at(start_time), Time.at(end_time)).map {|v|
            v.value
          }
          usage = values.inject{|sum, n| sum.to_f + n.to_f} / values.size
          st = usage.method(SUPPORT_COMPARISON_OPERATOR[@params["comparison_operator"]]).call(@params["threshold"])
          delete_resource(time)
          st
        when 'memory.usage'
        else
          raise "Unknown metric name: #{@metric_name}"
        end

      end

      private
      def set_variable(alm)
        raise ArgumentError unless alm.is_a?(Hash)
        alm.each {|k, v| instance_variable_set("@#{k}", v) }
      end

      def delete_resource(time)
        raise ArgumentError unless time.is_a?(Time)
        @resource.delete_all_since_at(time)
      end
    end

    class ResourceCapture
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper

      SUPPORT_METRIC_NAMES = {
        "cpu" => ['time', 'pid', 'usr_usage', 'system_usage', 'guest_usage', 'usage', 'cpu_number', 'cswch', 'nvcswch', 'usr_ms', 'system_ms', 'guest_ms'],
        "memory" => ['time', 'pid', 'minflt', 'majflt', 'vsz', 'rss', 'usage', 'minflt-nr', 'majflt-nr']
      }.freeze

      def initialize(node)
        @node = node
        @rpc = Isono::NodeModules::RpcChannel.new(@node)
      end

      def get_resources
        # TODO: add volume and network vif
        instlst = @rpc.request('hva-collector', 'get_instance_monitor_data', @node.node_id)

        h = {}
        instlst.each {|i|
          begin
            h["#{i[:uuid]}"] = {}

            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            raise "Unable to find the pid file: #{i[:uuid]}" unless File.exists?(pidfile)
            logger.debug("Find pidfile: #{pidfile}")

            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")

            cpu = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["cpu"] = parse_pidstat("cpu", cpu)

            memory = sh("pidstat -h -r -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["memory"] = parse_pidstat("memory", memory)

            logger.debug(h)

          rescue Exception => e
            logger.error("Error occured. [Instance ID: #{i[:uuid]}]")
            logger.error(e)
          end
        }
        h
      end

      private
      def parse_pidstat(metric_name, data)
        raise ArgumentError unless metric_name.is_a?(String)
        raise ArgumentError unless data.is_a?(Hash)

        metric = data[:stdout].split(/\n/)
        metric.shift

        initial_keys = SUPPORT_METRIC_NAMES[metric_name]
        raise "Unknown Metric type: #{metric_name}" if initial_keys.nil?
        
        values = []
        metric.each {|m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          m.pop
          next if m.include?("#")
          values << m
        }
        Hash[*initial_keys.zip(values.flatten.uniq).flatten]
      end

    end

    class Notification
      def initialize
      end
    end

  end
end
