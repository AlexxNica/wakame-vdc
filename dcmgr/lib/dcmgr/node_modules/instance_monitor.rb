# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class InstanceMonitor < Isono::NodeModules::Base
      include Dcmgr::Rpc::KvmHelper
      include Dcmgr::Logger

      initialize_hook do
        @thread_pool = Isono::ThreadPool.new(1, 'InstanceMonitor')
        @monitor = EventMachine::PeriodicTimer.new(5) {
          next if @thread_pool.queue.size > 0
          @thread_pool.pass {
            myinstance.check_instance
          }
        }
      end

      terminate_hook do
        @monitor.cancel
        @thread_pool.shutdown
      end

      def check_instance()
        instlst = rpc.request('hva-collector', 'get_alive_instances', manifest.node_id)
        instlst.find_all{|i| i[:state] == 'running' }.each { |i|
          begin
            check_kvm_process(i)
          rescue Exception => e
            if i[:status] == 'online'
              logger.error("#{e.class}, #{e.message}")

              rpc.request('hva-collector', 'update_instance', i[:uuid], {:status=>:offline}) { |req|
                req.oneshot = true
              }
              event.publish('hva/fault_instance', :args=>[i[:uuid]])
            end
            next
          end

          if i[:status] != 'online'
            rpc.request('hva-collector', 'update_instance', i[:uuid], {:status=>:online}) { |req|
              req.oneshot = true
            }
          end
        }
      end

      private
      def check_kvm_process(i)
        kvm_pid_path = File.expand_path("#{i[:uuid]}/kvm.pid", node.manifest.config.vm_data_dir)
        unless File.exists?(kvm_pid_path)
          raise "Unable to find the kvm.pid file: #{i[:uuid]}"
        end
        pid = File.read(kvm_pid_path).to_i
        unless File.exists?(File.expand_path(pid.to_s, '/proc'))
          raise "Unable to find the pid of kvm process: #{pid}"
        end
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end

  end
end
