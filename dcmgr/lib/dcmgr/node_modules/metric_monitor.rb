# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class MetricMonitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper
      include Dcmgr::ResourceMonitor

      initialize_hook do
        @monitor = {}
        @capture = MetricCapture.new
        @evaluate = MetricEvaluation.new

        logger.info("Start collect metric")
        EM.add_periodic_timer(5) do
          EM.defer do
            myinstance.collect_metric
          end
        end

        EM.defer do
          alarms = myinstance.update_alarm_data
          alarms.each { |h|
            @monitor[h[:uuid]] = myinstance.add_metric_timer(h)
          }
        end

        job = Isono::NodeModules::JobChannel.new(node)
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job.register_endpoint("resource-alarm-registry.#{node.node_id}", Isono::Rack.build do
            run proc { |req,res|
              app.call(req,res)
            }
            end)
      end

      terminate_hook do
      end

      def update_alarm(alarm_id)
        logger.debug("Update alarm: #{alarm_id}")
        alarm = rpc.request('alarm-collector', 'get_alarm', alarm_id)
        if alarm[:enabled]
          if @monitor[alarm[:uuid]]
            logger.debug("Reset evaluation timer: #{alarm[:uuid]} #{alarm[:metric_name]}")
            EM.next_tick do
              @monitor[alarm[:uuid]].cancel
              @monitor[alarm[:uuid]] = add_metric_timer(alarm)
            end
          else
            logger.debug("Set evaluation timer: #{alarm[:uuid]} #{alarm[:metric_name]}")
            EM.next_tick do
              @monitor[alarm[:uuid]] = add_metric_timer(alarm)
            end
          end
        else
          logger.debug("Remove evaluation timer: #{alarm[:uuid]} #{alarm[:metric_name]}")
          EM.next_tick do
            @monitor[alarm[:uuid]].cancel
            @monitor.delete(alarm[:uuid])
          end
        end
      end

      def delete_alarm(alarm_id)
        logger.debug("Remove evaluation timer: #{alarm_id}")
        alarm = rpc.request('alarm-collector', 'get_alarm', alarm_id)
        if alarm[:enabled] && @monitor[alarm[:uuid]]
          EM.next_tick do
            @monitor[alarm[:uuid]].cancel
            @monitor.delete(alarm[:uuid])
          end
        end
      end

      def collect_metric
        instlst = rpc.request('hva-collector', 'get_instance_monitor_data', manifest.node_id)
        instlst.each { |i|
          begin
            h = {"#{i[:uuid]}" => {}}
            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            raise "Unable to find the pid file: #{i[:uuid]}" unless File.exists?(pidfile)
            logger.debug("Find pidfile: #{pidfile}")
            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")
            cpu_usage = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            logger.debug(i[:uuid])
            h["#{i[:uuid]}"]["cpu"] = parse_pidstat(cpu_usage, "cpu")
            memory_usage = sh("pidstat -h -r -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["memory"] = parse_pidstat(memory_usage, "memory")
            logger.debug(h)
            EM.next_tick do
              @capture.push(h)
            end
            rpc.request('metric-collector', 'register_metric', i[:uuid], h) do |req|
              req.oneshot = true
            end
          rescue Exception => e
            logger.error("Error occured. [Instance ID: #{i[:uuid]}")
            logger.error(e)
          end
        }
      end

      def update_alarm_data
        logger.debug("Update alarm from database")
        ids = rpc.request('hva-collector', 'get_metric_monitor_instance_ids', @node.node_id)
        alarms = rpc.request('alarm-collector', 'get_resource_alarms', ids)
      end
      
      def add_metric_timer(alarm)
        EM.add_periodic_timer(alarm[:evaluation_periods]) do
          resource_id = alarm[:resource_id]
          metric = alarm[:metric_name].split('.')[0]
          data = @capture.get(resource_id, metric)
          logger.debug("Capture metric data: #{data}")
          @evaluate.push(resource_id, metric, data)
          @capture.delete(resource_id, metric, data)
          logger.debug("Evaluate metric data: #{alarm[:metric_name]}")
          if @evaluate.evaluate(alarm)
            logger.debug(alarm)
          end
        end            
      end

      private
      def parse_pidstat(data, metric_name)
        raise ArgumentError unless data.is_a?(Hash)
        metric = data[:stdout].split(/\n/)
        metric.shift

        case metric_name
        when "cpu"
          initial_keys = ['time', 'pid', 'usr_usage', 'system_usage', 'guest_usage', 'total_usage', 'cpu_number', 'cswch', 'nvcswch', 'usr_ms', 'system_ms', 'guest_ms']
        when "memory"
          initial_keys = ['time', 'pid', 'minflt', 'majflt', 'vsz', 'rss', 'memory_usage', 'minflt-nr', 'majflt-nr']
        else
        end

        values = []
        metric.each { |m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          m.pop
          next if m.include?("#")
          values << m
        }
        Hash[*initial_keys.zip(values.flatten.uniq).flatten]
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(@node)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end
  end
end
