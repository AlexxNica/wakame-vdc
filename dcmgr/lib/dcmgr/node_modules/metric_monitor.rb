# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class MetricMonitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper
      
      initialize_hook do
        @thread_pool = Isono::ThreadPool.new(1, 'MetricMonitor')
        @monitor = EventMachine::PeriodicTimer.new(5) {
          next if @thread_pool.queue.size > 0
          @thread_pool.pass {
            myinstance.dup.collect_metric
          }
        }
      end

      terminate_hook do
        @monitor.cancel
        @thread_pool.shutdown
      end

      def collect_metric
        logger.info("starting collect metric")
        instlst = rpc.request('hva-collector', 'get_instance_monitor_data', manifest.node_id)
        instlst.each { |i|
          begin
            h = {}
            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            raise "Unable to find the pid file: #{i[:uuid]}" unless File.exists?(pidfile)
            logger.debug(pidfile)
            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")
            cpu_usage = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            h["cpu"] = parse_pidstat(cpu_usage)
            logger.debug(h)
            rpc.request('metric-collector', 'register_metric', i[:uuid], h) do |req|
              req.onshot = true
            end
          rescue Exception => e
            logger.error("Error occured. [Instance ID: #{i[:uuid]}")
            logger.error(e)
          end
        }
      end

      private

      def parse_pidstat(metric)
        raise ArgumentError unless metric.is_a?(Hash)
        metric = metric[:stdout].split(/\n/)
        metric.shift

        initial_keys = ['time', 'pid', 'usr_usage', 'system_usage', 'guest_usage', 'total_usage', 'cpu_number', 'cswch', 'nvcswch', 'usr_ms', 'system_ms', 'guest_ms']
        values = []
        metric.each { |m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          m.pop
          next if m.include?("#")
          values << m
        }

        Hash[*initial_keys.zip(values.flatten.uniq).flatten]
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(@node)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end
  end
end
