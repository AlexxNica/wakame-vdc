# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class MetricMonitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper
      
      initialize_hook do
        @thread_pool = Isono::ThreadPool.new(1, 'MetricMonitor')
        @monitor = EventMachine::PeriodicTimer.new(30) {
          next if @thread_pool.queue.size > 0
          @thread_pool.pass {
            myinstance.dup.collect_metric
          }
        }
      end

      terminate_hook do
        @monitor.cancel
        @thread_pool.shutdown
      end

      def collect_metric
        logger.info("starting collect metric")
        instlst = rpc.request('hva-collector', 'get_instance_monitor_data', manifest.node_id)
        instlst.each { |i|
          begin
            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            logger.debug(pidfile)
            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")
            cpu_usage = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            h = parse_pidstat(cpu_usage)
            logger.debug(h)
          rescue Exception => e
              logger.error(e)
          end
        }
      end

      private

      def parse_pidstat(metric)
        raise ArgumentError unless metric.is_a?(Hash)
        metric = metric[:stdout].split(/\n/)
        logger.debug(metric)

        host_info = metric.shift
        
        keys = []
        values = []

        metric.each { |m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          if m.include?("#")
            m.delete("#")
            keys << m
          else
            values << m
          end
        }

        keys.flatten!
        values.flatten!

        Hash[*keys.zip(values).flatten]
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(@node)
      end

      def rpc
        @rcp ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end
  end
end
