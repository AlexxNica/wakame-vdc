# -*- coding: utf-8 -*-
module Dcmgr
  module NodeModules
    class MetricMonitor < Isono::NodeModules::Base
      include Dcmgr::Logger
      include Dcmgr::Helpers::CliHelper
      include Dcmgr::ResourceMonitor

      initialize_hook do
        @resource_cache = {}
        @monitor = {}
        @capture = MetricCapture.new
        @evaluate = MetricEvaluation.new
        EM.add_periodic_timer(5) do
          EM.defer do
            myinstance.collect_metric
          end
        end

        EM.defer do
          myinstance.update_alarm_data
          @resource_cache.values.each { |h|
            @monitor[h[:uuid]] ||= {}
            @monitor[h[:uuid]][h[:metric_name]] = EM.add_periodic_timer(10) do
              resource_id = h[:resource_id]
              metric = "cpu"
              data = @capture.get(resource_id, metric)
              @evaluate.push(resource_id, metric, data)
              @capture.delete(resource_id, metric, data)
            end            
          }
        end
      end

      terminate_hook do
      end

      def collect_metric
        logger.info("starting collect metric")
        instlst = rpc.request('hva-collector', 'get_instance_monitor_data', manifest.node_id)
        instlst.each { |i|
          begin
            h = {"#{i[:uuid]}" => {}}
            pidfile = "#{Dcmgr.conf.vm_data_dir}/#{i[:uuid]}/kvm.pid"
            raise "Unable to find the pid file: #{i[:uuid]}" unless File.exists?(pidfile)
            logger.debug(pidfile)
            kvmpid = File.read(pidfile)
            logger.debug("#{i[:uuid]} pid: #{kvmpid}")
            cpu_usage = sh("pidstat -h -u -w -T ALL -p #{kvmpid}")
            logger.debug(i[:uuid])
            h["#{i[:uuid]}"]["cpu"] = parse_pidstat(cpu_usage, "cpu")
            memory_usage = sh("pidstat -h -r -T ALL -p #{kvmpid}")
            h["#{i[:uuid]}"]["memory"] = parse_pidstat(memory_usage, "memory")
            logger.debug(h)
            EM.next_tick do
              @capture.push(h)
            end
            rpc.request('metric-collector', 'register_metric', i[:uuid], h) do |req|
              req.onshot = true
            end
          rescue Exception => e
            logger.error("Error occured. [Instance ID: #{i[:uuid]}")
            logger.error(e)
          end
        }
      end

      def update_alarm_data
        logger.debug("update alarm data from database")
        ids = rpc.request('hva-collector', 'get_metric_monitor_instance_ids', @node.node_id)
        alarms = rpc.request('metric-collector', 'get_alarm_data', ids)
        alarms.each { |alm|
          @resource_cache[alm[:uuid]] = alm
        }
      end
      
      private
      def parse_pidstat(data, metric_name)
        raise ArgumentError unless data.is_a?(Hash)
        metric = data[:stdout].split(/\n/)
        metric.shift

        case metric_name
        when "cpu"
          initial_keys = ['time', 'pid', 'usr_usage', 'system_usage', 'guest_usage', 'total_usage', 'cpu_number', 'cswch', 'nvcswch', 'usr_ms', 'system_ms', 'guest_ms']
        when "memory"
          initial_keys = ['time', 'pid', 'minflt', 'majflt', 'vsz', 'rss', 'memory_usage', 'minflt-nr', 'majflt-nr']
        else
        end

        values = []
        metric.each { |m|
          next if m.empty?
          m.lstrip!
          m = m.split(nil)
          m.pop
          next if m.include?("#")
          values << m
        }
        Hash[*initial_keys.zip(values.flatten.uniq).flatten]
      end

      def job
        @job ||= Isono::NodeModules::JobChannel.new(@node)
      end

      def rpc
        @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
      end

      def event
        @event ||= Isono::NodeModules::EventChannel.new(@node)
      end
    end
  end
end
