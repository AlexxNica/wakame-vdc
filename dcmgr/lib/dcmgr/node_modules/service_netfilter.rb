# -*- coding: utf-8 -*-
require 'isono'
module Dcmgr::NodeModules
  class ServiceNetfilter < Isono::NodeModules::Base
    include Dcmgr::Logger

    CHAIN_PREFIX="vdc".freeze

    initialize_hook do
      @worker_thread = Isono::ThreadPool.new(1, 'Netfilter')

      event = Isono::NodeModules::EventChannel.new(node)

      #TODO: Init all current vnics
      @worker_thread.pass {
        logger.info "Initializing service netfilter"
        myinstance.remove_all_chains

        ["init_vnic","destroy_vnic","add_tasks","flush_chains"].each {|event_name|
          event_queue = "hva.#{myinstance.node.manifest.node_instance_id}-#{event_name}"
          logger.info "Subscribing to #{event_queue}."
          myinstance.event.subscribe(event_queue,"#") do |args|
            @worker_thread.pass {
              logger.debug "event caught: '#{event_queue}'"
              myinstance.send(event_name,*args)
            }
          end
        }
      }
    end


    def init_vnic(vnic_id)
      # rpc.request('sg_handler', 'get_vnic_init_data', @node.node_id)

      #TODO: Add L2 chains
      create_chains(vnic_chains(vnic_id))
    end

    def destroy_vnic(vnic_id)
      remove_chains(vnic_chains(vnic_id))
    end

    def add_tasks(vnic_id,tasks)
    end

    def flush_chains(vnic_id,chains)
    end

    def remove_all_chains
      logger.info "Removing all chains prefixed by '#{CHAIN_PREFIX}'."
      #TODO: USE the remove_chains method for this
      system("for i in $(ebtables -L | grep 'Bridge chain: #{CHAIN_PREFIX}' | cut -d ' ' -f3 | cut -d ',' -f1); do ebtables -X $i; done")
      system("for i in $(iptables -L | grep 'Chain #{CHAIN_PREFIX}' | cut -d ' ' -f2); do iptables -X $i; done")
    end

    def event
      @event ||= Isono::NodeModules::EventChannel.new(@node)
    end

    private
    def remove_chains(chains)
      cmds = chains[:l2].map {|c| "ebtables -X #{c}" }
      cmds += chains[:l3].map{|c| "iptables -X #{c}" }
      exec cmds
    end

    def create_chains(chains)
      cmds = chains[:l2].map {|c| "ebtables -N #{c}; ebtables -P #{c} RETURN" }
      cmds += chains[:l3].map {|c| "iptables -N #{c}" }
      exec cmds
    end

    def exec(cmds)
      #TODO: Make vebose commands options
      puts cmds.join("\n")
      system cmds.join("\n")
    end

    def vnic_chains(vnic_id)
      # L2 has the refencers chains and L3 has the referencees chains.
      # Let's say there's secg A that references secg B in one of its rules.
      # The rules are only L3 so secg A needs the referencees chain to add the rules itself.
      # Secg A needs the referencers chain so it can accept ARP packets from vnics in secg B.
      #
      # Basically secg A is referencing secg B so vnics in secg A are referencers and vnics
      # in secg B are referencees. a referencee needs to know about its referencer and a
      # referencer needs to know about its referencee.
    {
      :l2 => [
        "#{CHAIN_PREFIX}_#{vnic_id}_d",
        "#{CHAIN_PREFIX}_#{vnic_id}_friends",
        "#{CHAIN_PREFIX}_#{vnic_id}_referencers",
      ],
      :l3 => [
        "#{CHAIN_PREFIX}_#{vnic_id}_d",
        "#{CHAIN_PREFIX}_#{vnic_id}_friends",
        "#{CHAIN_PREFIX}_#{vnic_id}_referencees",
        "#{CHAIN_PREFIX}_#{vnic_id}_secg"
      ]
    }
    end

    # def rpc
    #   @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
    # end
  end
end
