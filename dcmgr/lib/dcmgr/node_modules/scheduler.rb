# -*- coding: utf-8 -*-
require 'isono'

module Dcmgr
  module NodeModules
    class Scheduler < Isono::NodeModules::Base
      include Dcmgr::Logger

      # module_module: bin/collector
      initialize_hook do
        app = Isono::Rack::ObjectMethod.new(myinstance)
        job = Isono::NodeModules::JobChannel.new(node)
        job.register_endpoint('scheduler', Isono::Rack.build do
                                use Isono::Rack::DataStore
                                run proc { |req, res|
                                  Thread.current[Models::BaseNew::LOCK_TABLES_KEY] = {}
                                  app.call(req, res)
                                }
                              end)
      end

      terminate_hook do
      end

      def schedule_instance(instance_id)
        instance = Models::Instance[instance_id]
        vol = Models::Volume.find(:instance_id=>instance.id, :boot_dev=>1)
        
        Dcmgr::Scheduler.host_node.schedule(instance)
        Dcmgr::Scheduler.network.schedule(instance)
        lease_ip_address_to_instance(instance)
        instance.save
        
        instance.state = :pending
        instance.save


        case instance.image.boot_dev_type
        when Models::Image::BOOT_DEV_SAN
          Dcmgr::Scheduler.storage_node.schedule(vol)
          vol.state = :pending
          vol.save
          
          commit_transaction
          
          repository_address = Dcmgr::StorageService.repository_address(vol.snapshot.destination_key)
          self.job.submit("sta-handle.#{vol.storage_node.node_id}",
                          'create_volume_and_run_instance', vol.canonical_uuid, instance.canonical_uuid, repository_address)
        when Models::Image::BOOT_DEV_LOCAL
          commit_transaction
          self.job.submit("hva-handle.#{instance.host_node.node_id}",
                          'run_local_store', instance.canonical_uuid)
        else
          raise "Unknown boot type"
        end
        event.publish('instance.scheduled', :args=>[instance.canonical_uuid])
        
      rescue => e
        rollback_transaction rescue nil
        
        logger.error(e)
        instance.destroy if instance
        vol.destroy if vol
        return
      end

      def schedule_instance_ha(instance_id, vol)
        instance = Models::Instance[instance_id]
        
        Dcmgr::Scheduler.host_node_ha.schedule(instance)
        Dcmgr::Scheduler.network.schedule(instance)
        instance.save
        
        instance.state = :pending
        instance.save

        commit_transaction
        case instance.image.boot_dev_type
        when Models::Image::BOOT_DEV_SAN
          self.job.submit("hva-handle.#{instance.host_node.node_id}", 'run_vol_store', instance.canonical_uuid, vol.canonical_uuid)
        when Models::Image::BOOT_DEV_LOCAL
          self.job.submit("hva-handle.#{instance.host_node.node_id}", 'run_local_store', instance.canonical_uuid)
        else
          raise "Unknown boot type"
        end
        event.publish('instance.scheduled', :args=>[instance.canonical_uuid])
        
      rescue => e
        rollback_transaction rescue nil
        
        logger.error(e)
        instance.destroy if instance
        vol.destroy if vol
        return
      end

      def schedule_start_instance(instance_id)
        instance = Models::Instance[instance_id]
        vol = Models::Volume.find(:instance_id=>instance.id, :boot_dev=>1)
        
        Dcmgr::Scheduler.host_node.schedule(instance)
        lease_ip_address_to_instance(instance)
        instance.save
        
        instance.state = :pending
        instance.save

        commit_transaction
        case instance.image.boot_dev_type
        when Models::Image::BOOT_DEV_SAN
          self.job.submit("hva-handle.#{instance.host_node.node_id}", 'run_vol_store', instance.canonical_uuid, vol.canonical_uuid)
        when Models::Image::BOOT_DEV_LOCAL
          self.job.submit("hva-handle.#{instance.host_node.node_id}", 'run_local_store', instance.canonical_uuid)
        else
          raise "Unknown boot type"
        end
        event.publish('instance.scheduled', :args=>[instance.canonical_uuid])
        
      rescue => e
        rollback_transaction rescue nil
        
        logger.error(e)
        instance.destroy if instance
        vol.destroy if vol
        return
      end

      def schedule_volume(volume_id)
        volume = Models::Volume[volume_id]
        
        Dcmgr::Scheduler.storage_node.schedule(volume)
        volume.save

        volume.state = :pending
        volume.save
        
        commit_transaction
        
        repository_address = nil
        if volume.snapshot
          repository_address = Dcmgr::StorageService.repository_address(volume.snapshot.destination_key)
        end
              
        self.job.submit("sta-handle.#{volume.storage_node.node_id}",
                        'create_volume', volume.canonical_uuid, repository_address)
      rescue => e
        rollback_transaction rescue nil

        logger.error(e)
        volume.destroy
      end

      protected
      # commit manually before return from the request block
      def commit_transaction
        db = Sequel::DATABASES.first
        db << db.__send__(:commit_transaction_sql)
      end

      def rollback_transaction
        db = Sequel::DATABASES.first
        db << db.__send__(:rollback_transaction_sql)
      end
      
      def job()
        Isono::NodeModules::JobChannel.new(self.node)
      end

      def event()
        Isono::NodeModules::EventChannel.new(self.node)
      end

      def lease_ip_address_to_instance(instance)
        instance.nic.each { |nic|
          network = nic.network
          if network && nic.direct_ip_lease.empty?
            Models::IpLease.lease(nic, network)
          end
          nat_network = nic.nat_network 
          if nat_network && nic.nat_ip_lease.empty?
            Models::IpLease.lease(nic, nat_network)
          end
        }
      end
      
    end
  end
end
