# -*- coding: utf-8 -*-

require 'spec_helper'
require 'isono'
require 'webmock/rspec'

describe Dcmgr::NodeModules::VnetCollector do

  let(:vnet_webapi_host) { Dcmgr::Configurations.dcmgr.features.vnet_endpoint }
  let(:vnet_webapi_port) { Dcmgr::Configurations.dcmgr.features.vnet_endpoint_port }
  let(:vnet_webapi) { "http://#{vnet_webapi_host}:#{vnet_webapi_port}" }


  let(:vnet_collector) { Dcmgr::NodeModules::VnetCollector }

  let(:value_object) do
    double("value_object").tap do |v|
      v.should_receive(:copy_instance_variables).with( an_instance_of(Dcmgr::NodeModules::VnetCollector) ).and_return(true)
    end
  end

  let(:isono_node_mock) do
    double("isono_node").tap do |i|
      i.should_receive(:is_a?).and_return(Isono::Node)
      i.should_receive(:value_objects).twice.and_return({vnet_collector => value_object})
    end
  end

  let(:instance) { Fabricate(:instance_with_network_vif) }

  subject { vnet_collector.new(isono_node_mock) }

  describe "schedule_vifs(instance_uuid)" do
    it "sends network_vif params to create interface in vnet" do
      WebMock.disable_net_connect!(allow_localhost: true)
      network_vif_name = instance.network_vif.first.canonical_uuid.sub(/v/, '')
      stub_request(:any, "localhost").and_return(:status => 200, :body => "test ok")
      #stub_request(:post, "#{vnet_webapi}/api/1.0/instance.json?mode=host&port_name=#{network_vif_name}").with(:headers => {'Accept'=>'*/*', 'Accept-Encoding'=>'gzip;q=1.0,deflate;q=0.6,identity;q=0.3', 'User-Agent'=>'Ruby'}).to_return(:status => 200, :body => "", :headers => {})
      ret = subject.schedule_vifs(instance.canonical_uuid)
      expect(ret).to eq "test ok"
    end
  end
end
