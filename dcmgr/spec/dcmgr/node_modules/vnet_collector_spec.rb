# -*- coding: utf-8 -*-

require 'spec_helper'
require 'isono'
require 'webmock/rspec'

WebMock.disable_net_connect!(allow_localhost: true)

def request_params(params)
  ret = ""
  params.each do |k,v|
    ret = "#{ret}#{k.to_sym}=#{v}&"
  end
  ret.chop!
end

def stub_vnet_request(api_suffix, params)
  stub_request(
    :post, "http://localhost:9090/api/1.0/#{api_suffix}.json?#{request_params(params)}"
  ).to_return(:body => "{\"uuid\":\"#{params[:uuid]}\"}")
end

describe Dcmgr::NodeModules::VnetCollector do

  let(:vnet_collector) { Dcmgr::NodeModules::VnetCollector }

  let(:value_object) do
    double("value_object").tap do |v|
      v.should_receive(:copy_instance_variables).with( an_instance_of(Dcmgr::NodeModules::VnetCollector) ).and_return(true)
    end
  end

  let(:isono_node_mock) do
    double("isono_node").tap do |i|
      i.should_receive(:is_a?).and_return(Isono::Node)
      i.should_receive(:value_objects).twice.and_return({vnet_collector => value_object})
    end
  end

  let(:instance) { Fabricate(:instance_with_network_vif) }

  subject { vnet_collector.new(isono_node_mock) }

  describe "schedule_vifs(instance_uuid)" do
    it "sends network_vif params to create interface in vnet" do

      expected_retval = []
      instance.network_vif.each do |vif|
        if_uuid = vif.canonical_uuid.sub(/v/, '')

        params = {
          :uuid => if_uuid,
          :network_uuid => vif.network.canonical_uuid,
          :mac_address => vif.mac_addr.scan(/.{1,2}/).join(':'),
          :port_name => if_uuid
        }

        expected_retval << params[:uuid]

        stub_vnet_request("interfaces", params)
      end

      ret = subject.schedule_vifs(instance.canonical_uuid)
      expect(ret).to eq expected_retval
    end
  end
end
