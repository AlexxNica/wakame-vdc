#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'dcmgr/rubygems'
require 'dcmgr'
require 'isono'
require 'net/http'
require 'thin'
require 'sinatra/base'
require 'em-http'
require 'multi_json'

include Isono::Runner::RpcServer

path = ['/etc/wakame-vdc/bksta.conf', File.expand_path('config/bksta.conf', Dcmgr::DCMGR_ROOT)].find { |i| File.exists?(i) }
abort("ERROR: Failed to load bksta.conf") if path.nil?

begin
  Dcmgr.instance_eval {
    @conf = Dcmgr::Configurations::Bksta.load(path)
  }
rescue NoMethodError => e
  abort("Syntax Error: #{path}\n  #{e.backtrace.first} #{e.message}")
rescue Dcmgr::Configuration::ValidationError => e
  abort("Validation Error: #{path}\n  " +
        e.errors.join("\n  ")
        )
end
Dcmgr.run_initializers('logger')

class CopyProcessor < Isono::NodeModules::Base
  include Dcmgr::Logger
  
  initialize_hook do
    Dcmgr::Messaging::JobQueue.backend :AMQPClient, self.node
    
    EM.next_tick do
      queue_worker = Dcmgr::NodeModules::JobQueueWorker.new(self.node)
      queue_worker.subscribe("backup_storage.copy_to.#{self.node.node_id}", 1) do |job|
        myinstance.submit_pull_job(job)
      end

      queue_worker.subscribe("backup_storage.pull_from.#{self.node.node_id}", 1) do |job|
        myinstance.pull_file_job(job)
      end
    end
  end


  include Dcmgr::Helpers::CliHelper

  def json_post(uri, params)
    Net::HTTP.new(uri.host, uri.port).post(uri.path, MultiJson.dump(params), {'Content-Type'=>'application/json'})
  end
  
  def submit_pull_job(job)
    params = job[:params]

    uri = Dcmgr.conf.destinations[params[:destination]].dup
    if uri.nil?
      raise "Unknown destination: #{params[:destination]}"
    end

    uri.path += '/submit_pull_job'
    
    tryagain do
      post_params = params.merge({
        'src' => Dcmgr.conf.export_uri + "/" + params[:backup_object][:object_key],
      })
      logger.info("Sending POST /submit_pull_job: #{uri.to_s}, #{post_params}")

      res = json_post(uri, post_params)
      unless res.is_a?(Net::HTTPSuccess)
        sleep 3
        raise "Failed to submit pull job: #{res} #{uri.to_s}"
      end

      true
    end
  end

  def pull_file_job(job)
    params = job[:params]

    src_uri = URI.parse(params[:src])
    logger.info("Starting file pull: #{src_uri.to_s}")
    if src_uri.scheme == 'scp'
      sh("scp #{src_uri.host}:#{src_uri.path} /dev/null")
    else
      raise "Unsupported transport method: #{src_uri.to_s}"
    end
  end
end

class DestinationMonitor < Isono::NodeModules::Base
  include Dcmgr::Logger
  
  initialize_hook do
    @destinations = {}
    Dcmgr.conf.destinations.each { |name, uri|
      @destinations[name] = {:uri=>uri, :status=>false, :last_monitor_at=>nil}
    }

    logger.info("Copy destinations to be monitored: #{@destinations.keys.join(', ')}")

    do_http_ping = lambda do
      EM::Iterator.new(@destinations).map(proc{ |d, iter|
                                            n, v = d
                                            http = EM::HttpRequest.new(v[:uri].to_s + '/ping').get
                                            http.callback {
                                              if http.response_header.status == 200
                                                v[:status]=true
                                              else
                                                v[:status]=false
                                              end
                                              v[:last_monitor_at]=Time.now
                                              iter.return(v)
                                            }
                                            http.errback {
                                              v[:status]=false
                                              v[:last_monitor_at]=Time.now
                                              iter.return(v)
                                            }
                                          }, proc { |results|
                                            failed_dests = @destinations.values.select { |v| !v[:status] }
                                            if !failed_dests.empty?
                                              logger.warn("Failed destinations: #{failed_dests.map{ |v | v[:uri] }.join(', ')}")
                                            end
                                            #logger.debug("Checked destinations: #{@destinations.keys.join(', ')}")
                                          })
    end

    EM.next_tick(&do_http_ping)
    EM.add_periodic_timer(10, &do_http_ping)
  end
end

manifest = Isono::Runner::RpcServer::DEFAULT_MANIFEST.dup
manifest.instance_eval do
  node_name 'bksta'
  node_instance_id `/bin/hostname`.chomp

  load_module Isono::NodeModules::NodeHeartbeat
  load_module Dcmgr::NodeModules::JobQueueWorker
  load_module CopyProcessor
  load_module DestinationMonitor
end

Isono.at_disconnected do
  EM.stop { exit }
end

require 'fiber'

class APIProxy < Sinatra::Base
  include Dcmgr::Logger

  def initialize(node)
    super()
    @node = node
  end

  # Fibered rpc request for EM's async context.
  def rpc_request(*args)
    fib = Fiber.current
    req = Isono::NodeModules::RpcChannel.new(@node).request(*args) { |req|
      req.timeout_sec = Dcmgr.conf.site_over_rpc_timeout
      req.on_success { |r|
        fib.resume(r)
      }
      
      req.on_error { |r|
        fib.resume(RuntimeError.new(r))
      }
    }
    result = Fiber.yield
    if result.is_a?(::Exception)
      raise result
    else
      return result
    end
  end

  get '/ping' do
    if params[:code]
      body("PONG: #{params[:code]}")
    else
      body("PONG")
    end
  end

  def error_async(code, body=nil)
    status(code)
    body(body) if body
  end

  condition do
    if mime_type('json') == request.content_type
      @params = MultiJson.load(request.body)
      true
    else
      false
    end
  end
  post '/submit_pull_job' do
    src = params['src']
    if src.nil?
      error(400, "Invalid parameter: src")
    end

    new_bo_data = {}
    if params['backup_object']
      %w(account_id display_name service_type size allocation_size container_format checksum description).each { |k|
        new_bo_data[k.to_sym]=params['backup_object'][k.to_s]
      }
    else
      error(400, "Invalid parameter: backup_object")
    end

    res = {}
    Fiber.new do
      begin
        if params['image']
          res = rpc_request('sta-collector', 'register_image_transfer', @node.node_id, params['image'], new_bo_data)
        else
          bo = res[:backup_object] = rpc_request('sta-collector', 'register_backup_object_transfer', @node.node_id, new_bo_data)
        end
      rescue ::Exception => e
        logger.error(e)
        error_async(500, "Failed at resource registration: backup_object: #{e}")
        return
      end

      fib = Fiber.current
      job = Dcmgr::Messaging.job_queue.submit("backup_storage.pull_from.#{@node.node_id}",
                                              bo[:uuid],
                                              {:src=>params['src']}
                                              ) do |req|
        req.timeout_sec = Dcmgr.conf.site_over_rpc_timeout
        
        req.on_success { |r|
          fib.resume("OK")
        }
        
        req.on_error { |r|
          fib.resume("ERROR")
        }
      end
      Fiber.yield

      status(200)
      body(MultiJson.dump(res))

      env['async.callback'][response.finish]
    end.resume

    return -1
  end
end


class BackupStorageHandler < EndpointBuilder
  job :export_object do
  end

  job :fetch_object do
    params[:src_uri]
  end
end


start(manifest) do
  thin = Thin::Server.new('0.0.0.0', 8889, APIProxy.new(@node))
  thin.start!
#  endpoint "bksta-handle.#{@node.node_id}", BackupStorageHandler
end
