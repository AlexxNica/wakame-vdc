#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'dcmgr/rubygems'
require 'dcmgr'
require 'isono'

include Isono::Runner::RpcServer

path = ['/etc/wakame-vdc/bksta.conf', File.expand_path('config/bksta.conf', Dcmgr::DCMGR_ROOT)].find { |i| File.exists?(i) }
abort("ERROR: Failed to load bksta.conf") if path.nil?

begin
  Dcmgr.instance_eval {
    @conf = Dcmgr::Configurations::Bksta.load(path)
  }
rescue NoMethodError => e
  abort("Syntax Error: #{path}\n  #{e.backtrace.first} #{e.message}")
rescue Dcmgr::Configuration::ValidationError => e
  abort("Validation Error: #{path}\n  " +
        e.errors.join("\n  ")
        )
end

class TestWorker < Isono::NodeModules::Base
  include Dcmgr::Logger
  
  initialize_hook do
    Dcmgr::Messaging::JobQueue.backend :AMQPClient, self.node
    
    @worker_thread = Isono::ThreadPool.new(4)
    @max_attempts = 3
    @pollers = {}

    EM.next_tick do
      myinstance.poll
    end
  end

  def subscribe(queue_name)
    return if @pollers.has_key?(queue_name)

    poller = @pollers[queue_name] = Poller.new(queue_name, 1, self)
    poller.poll
  end

  class Poller
    def initialize(queue_name, concurrency, worker)
      @queue_name = queue_name
      @concurrency = concurrency
      @worker = worker
    end
  end
  
  def poll
    @worker_thread.pass do
      begin
        pop_once
      rescue ::Exception => e
        logger.error("Rescheduling queue pop after ?? seconds. Something went wrong.: #{e.message}")
        logger.error(e)
        EM.add_timer(1) { poll }
      end
    end
  end

  private

  def pop_once
    job = pop_job
    if job.nil?
      logger.debug("Rescheduling queue pop after ?? seconds. None of pending jobs found.")
      EM.add_timer(1) { poll }
    else
      begin
        run(job)
        logger.info("Finished Job successfully: #{job[:uuid]}")
        Dcmgr::Messaging.job_queue.finish_success(job[:uuid])
        EM.next_tick { poll }
      rescue ::Exception => e
        if job[:retry_count] < job[:retry_max]
          logger.info("Running Job Failed. Re-queueing. (retry current #{job[:retry_count]} < max #{job[:retry_max]}) : #{job[:uuid]}: #{e.message}")
        else
          logger.info("Running Job Failed. Giving up. (retry current #{job[:retry_count]} = max #{job[:retry_max]}): #{job[:uuid]}: #{e.message}")
        end
        Dcmgr::Messaging.job_queue.finish_fail(job[:uuid], e.message)
        raise
      end
    end
  end

  def pop_job
    attempts = 0
    job = nil
    begin
      #job = Dcmgr::Messaging.job_queue.pop("backup_storage.copy_to.#{self.node.node_id}", self.node.node_id)
      job = Dcmgr::Messaging.job_queue.pop("backup_storage.copy_to.bksta", self.node.node_id)
      if job
        logger.info("Found Job: #{job[:uuid]}")
      else
        logger.debug("None of pending jobs found.")
      end
    rescue => e
      attempts += 1
      if attempts <= @max_attempts
        logger.error("Failed to pop queue. Going to retry after ?? sec. [#{attempts} (current) <= #{@max_attempts} (max)]")
        wait
        retry
      else
        logger.error("Give up to pop queue exceeds max_attemps retry count. #{@max_attempts}")
      end
    end
    job
  end

  def wait
    sleep 5
  end

  def run(job)
    logger.info("Starting Job: #{job[:uuid]}")
    puts job[:uuid]
    sleep 5
  end

end


manifest = Isono::Runner::RpcServer::DEFAULT_MANIFEST.dup
manifest.instance_eval do
  node_name 'bksta'
  node_instance_id `/bin/hostname`.chomp

  load_module Isono::NodeModules::NodeHeartbeat
  load_module TestWorker
end

Isono.at_disconnected do
  EM.stop { exit }
end

class BackupStorageHandler < EndpointBuilder
  job :export_object do
  end

  job :fetch_object do
    params[:src_uri]
  end
end


start(manifest) do
#  endpoint "bksta-handle.#{@node.node_id}", BackupStorageHandler
end
