#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'dcmgr/rubygems'
require 'dcmgr'
require 'isono'

include Isono::Runner::RpcServer

class ZfsHandler < EndpointBuilder
  include Dcmgr::Logger
  include Dcmgr::Helpers::CliHelper
  
  job :create_volume do
    volume_id = request.args[0]
    data = rpc.request('sta-collector', 'get_volume', volume_id)
    raise "Invalid volume state: #{data[:state]}" unless data[:state].to_s == 'registering'

    unless data[:snapshot_id].nil?
      sdata = rpc.request('sta-collector', 'get_snapshot', data[:snapshot_id])
      raise "Invalid snapshot state: #{sdata[:state]}" unless sdata[:state].to_s == 'available'
    end
    logger.info("creating new volume #{volume_id}")

    rpc.request('sta-collector', 'update_volume', volume_id, {:state=>:creating, :export_path=>data[:uuid]})

    vol_path = "#{data[:storage_pool][:export_path]}/#{data[:uuid]}"
    `zfs list #{File.dirname(vol_path)} > /dev/null 2>&1`
    if $?.exitstatus != 0
      # create parent filesystem
      `zfs create -p #{File.dirname(vol_path)}`
      logger.info("create parent filesystem: #{File.dirname(vol_path)}")
    end

    if sdata
      # create volume from snapshot
      v = `zfs receive #{vol_path} < #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}.zsnap`
      if $?.exitstatus != 0
        raise "volume already exists: #{volume_id}"
      end

      v = `zfs destroy #{vol_path}@#{sdata[:uuid]}`
      if $?.exitstatus != 0
        raise "volume snapshot has not deleted: #{volume_id}@#{sdata[:uuid]}"
      end

      vl = `zfs list #{vol_path}`
      if vl.nil? || $?.exitstatus != 0
        raise "volume has not be created: #{volume_id}"
      end
    else
      # create volume
      v = `zfs create -p -V #{data[:size]}m #{vol_path}`
      if $?.exitstatus != 0
        raise "volume already exists: #{volume_id}"
      end
      vl = `zfs list #{vol_path}`
      if vl.nil? || $?.exitstatus != 0
        raise "volume has not be created: #{volume_id}"
      end
    end

    logger.info("created new volume: #{volume_id}")

    vr = `zfs shareiscsi=on #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
    if $?.exitstatus != 0
      raise "failed iscsi target request: #{volume_id}"
    end
    il = `iscsitadm list target -v #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
    if $?.exitstatus != 0
      raise "iscsi target has not be created #{volume_id}"
    end
    il = il.downcase.split("\n").select {|row| row.strip!}
    # :transport_information => {:iqn => "iqn.1986-03.com.sun:02:787bca42-9639-44e4-f115-f5b06ed31817", :lun => 0}
    opt = {:iqn => il[0].split(": ").last, :lun=>il[6].split(": ").last.to_i}

    rpc.request('sta-collector', 'update_volume', volume_id, {:state=>:available, :transport_information=>opt})
    logger.info("registered iscsi target: #{volume_id}")
  end

  job :delete_volume do
    volume_id = request.args[0]
    data = rpc.request('sta-collector', 'get_volume', volume_id)
    logger.info("#{volume_id}: start deleting volume.")
    errcount = 0
    if data[:state].to_s == 'deleted'
      raise "#{volume_id}: Invalid volume state: deleted"
    end
    if data[:state].to_s != 'deregistering'
      logger.warn("#{volume_id}: Unexpected volume state but try again: #{data[:state]}")
    end
    
    # deregisterd iscsi target
    begin
      sh("/usr/sbin/zfs shareiscsi=off #{data[:storage_pool][:export_path]}/#{data[:uuid]}")
    rescue => e
      logger.error("#{volume_id}: Failed to delete ISCSI target entry.")
      errcount += 1
    end
    
    rpc.request('sta-collector', 'update_volume', volume_id, {:state=>:deleting})
    
    # delete volume
    begin 
      sh("/usr/sbin/zfs destroy #{data[:storage_pool][:export_path]}/#{data[:uuid]}")
    rescue => e
      logger.error("#{volume_id}: Failed to delete zfs volume: #{data[:storage_pool][:export_path]}/#{data[:uuid]}")
      errcount += 1
    end

    rpc.request('sta-collector', 'update_volume', volume_id, {:state=>:deleted, :deleted_at=>Time.now.utc})
    if errcount > 0
      logger.info("#{volume_id}: Encountered one or more errors during deleting.")
    else
      logger.info("#{volume_id}: Deleted volume successfully.")
    end
  end

  job :create_snapshot do
    snapshot_id = request.args[0]
    sdata = rpc.request('sta-collector', 'get_snapshot', snapshot_id) unless snapshot_id.nil?
    data = rpc.request('sta-collector', 'get_volume', sdata[:origin_volume_id])
    logger.info("create new snapshot: #{snapshot_id}")
    raise "Invalid volume state: #{data[:state]}" unless data[:state].to_s == 'available' || data[:state].to_s == 'attached'

    logger.info("creating new snapshot: #{snapshot_id}")

    vol_path = "#{data[:storage_pool][:export_path]}/#{data[:uuid]}"
    snap_dir = "#{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}"
    unless File.exist?(snap_dir)
      # create a directory to save snapshot
      `mkdir -p #{snap_dir}`
      logger.info("create a directory: #{snap_dir}")
    end
    snap = `zfs snapshot #{vol_path}@#{sdata[:uuid]}`

    snap_send = `zfs send #{vol_path}@#{sdata[:uuid]} > #{snap_dir}/#{sdata[:uuid]}.zsnap`
    snap_delete = `zfs destroy #{vol_path}@#{sdata[:uuid]}`

    rpc.request('sta-collector', 'update_snapshot', snapshot_id, {:state=>:available})
    logger.info("created new snapshot: #{snapshot_id}")
  end

  job :delete_snapshot do
    snapshot_id = request.args[0]
    sdata = rpc.request('sta-collector', 'get_snapshot', snapshot_id)
    data = rpc.request('sta-collector', 'get_volume', sdata[:origin_volume_id])
    logger.info("deleting snapshot: #{snapshot_id}")
    raise "Invalid snapshot state: #{sdata[:state]}" unless sdata[:state].to_s == 'deleting'

    logger.info("deleting snapshot: #{snapshot_id}")

    system("rm -rf #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}.zsnap")
    raise "snapshot has not be deleted" if $?.exitstatus != 0

    rpc.request('sta-collector', 'update_snapshot', snapshot_id, {:state=>:deleted, :deleted_at=>Time.now.utc})
    logger.info("deleted snapshot: #{snapshot_id}")
  end

  def rpc
    @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
  end

  def jobreq
    @jobreq ||= Isono::NodeModules::JobChannel.new(@node)
  end

  def event
    @event ||= Isono::NodeModules::EventChannel.new(@node)
  end
end

manifest = Isono::Runner::RpcServer::DEFAULT_MANIFEST.dup
manifest.instance_eval do
  node_name 'sta'
  node_instance_id "#{Isono::Util.default_gw_ipaddr}"

  load_module Isono::NodeModules::NodeHeartbeat
end

start(manifest) do
  endpoint "zfs-handle.#{@node.node_id}", ZfsHandler
end
