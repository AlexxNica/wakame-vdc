# -*- coding: utf-8 -*-

module Vdc
  module NodeModules
    class StaLoader < Isono::NodeModules::Base
      include Logger

      config_section do |c|
      end

      initializer_hook do
      end

      terminate_hook do
      end

      def on_create(data)
        data = Serializer.instance.unmarshal(data)
        DataStore.pass {
          # created new volume
          state = 1
          v = `zfs create -V #{data[:size]}g #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            state = 4
          end
          vl = `zfs list #{data[:pool_name]}/#{data[:export_path]}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            state = 4
          end
          opts = {:uuid=>data[:uuid], :state => state, :export_path=>data[:export_path]}
          # EventMachine.schedule {
          #   ManagerModules::RpcChannel.instance.async_request('storage_locator', 'state_changed', Serializer.instance.marshal(opts))
          # }
          logger.info("creating new volume: #{data[:uuid]}")

          # registered iscsi target
          state = 2
          vr = `zfs shareiscsi=on #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            logger.info("failed iscsi target request")
            state = 4
          end
          il = `iscsitadm list target -v #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            state = 4
          end
          il = il.downcase.split("\n").select {|row| row.strip!}
          opts = {:uuid => data[:uuid], :state => state, :transport_information =>{:iqn => il[0].split(": ").last, :lun=>il[6].split(": ").last.to_i}}
          # EventMachine.schedule {
          #   ManagerModules::RpcChannel.instance.async_request('storage_locator', 'state_changed', Serializer.instance.marshal(opts))
          # }
          logger.info("registering volume: #{data[:uuid]}")
        }
      end

      def on_delete(data)
      end
    end
  end
end
