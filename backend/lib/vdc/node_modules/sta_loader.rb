# -*- coding: utf-8 -*-
require 'stm/volume_context'

module Vdc
  module NodeModules
    class StaLoader < Isono::NodeModules::Base
      include Isono::Logger

      config_section do |c|
      end

      initialize_hook do
        app = myinstance
        rpc = Isono::NodeModules::JobChannel.new(node)
        rpc.register_endpoint("sta-loader.#{node.node_id}", Isono::Rack.build do
                                run Isono::Rack::ObjectMethod.new(app)
                              end)
      end

      terminate_hook do
      end

      def create(volume_id)
        job = Stm::VolumeContext.new(volume_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        data = rpc.request('sta-collector', 'get_volume', volume_id)
        sdata = rpc.request('sta-collector', 'get_snapshot', data[:snapshot_id]) unless data[:snapshot_id].nil?
        job.stm.state=data[:state].to_sym
        job.stm.on_create

        vol_path = "#{data[:storage_pool][:export_path]}/#{data[:export_path]}"
        if sdata
          `zfs list #{File.dirname(vol_path)} > /dev/null 2>&1`
          if $?.exitstatus != 0
            # create parent filesystem
            `zfs create -p #{File.dirname(vol_path)}`
          end
          
          v = `zfs receive #{vol_path} < #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}.zsnap`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            job.stm.on_fail
          end

          v = `zfs destroy #{vol_path}@#{sdata[:uuid]}`
          if $?.exitstatus != 0
            logger.info("volume snapshot has not deleted")
            job.stm.on_fail
          end
          vl = `zfs list #{vol_path}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            job.stm.on_fail
          end
        else
          v = `zfs create -p -V #{data[:size]}m #{vol_path}`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            job.stm.on_fail
          end
          vl = `zfs list #{vol_path}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            job.stm.on_fail
          end
        end

        rpc.request('sta-collector', 'update_volume', job.to_hash(:export_path=>data[:export_path]))
        logger.info("creating new volume: #{data[:uuid]}")

        job.stm.on_register
        vr = `zfs shareiscsi=on #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
        # if $?.exitstatus != 0
        #   logger.info("failed iscsi target request")
        #   job.stm.on_fail
        # end
        il = `iscsitadm list target -v #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
        if $?.exitstatus != 0
          job.stm.on_fail
        end
        il = il.downcase.split("\n").select {|row| row.strip!}
        opt = {:iqn => il[0].split(": ").last, :lun=>il[6].split(": ").last.to_i}
        # opt = {:iqn => "iqn.1986-03.com.sun:02:787bca42-9639-44e4-f115-f5b06ed31817", :lun => 0}

        rpc.request('sta-collector', 'update_volume', job.to_hash(:transport_information=>opt))
        logger.info("registering volume: #{data[:uuid]}")
      end
      
      def delete(volume_id)
        job = Stm::VolumeContext.new(volume_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        data = rpc.request('sta-collector', 'get_volume', volume_id)
        job.stm.state=data[:state].to_sym

        # deregisterd iscsi target
        job.stm.on_delete
        vr = `zfs shareiscsi=off #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        il = `iscsitadm list target #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        unless il.empty?
          logger.debug("iscsi target has not deleted")
          job.stm.on_fail
        end

        rpc.request('sta-collector', 'update_volume', job.to_hash)
        return false if job.state == :failed
        logger.info("deregistered iscsi: #{data[:uuid]}")

        # delete volume
        job.stm.on_delete
        job.on_delete
        v = `zfs destroy #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        vl = `zfs list #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        unless vl.empty?  
          logger.debug("volume has not deleted")
          job.stm.on_fail
        end

        rpc.request('sta-collector', 'update_volume', job.to_hash)
        return false if job.state == :failed
        logger.info("deleted volume: #{data[:uuid]}")
      end

      def create_snapshot(snapshot_id)
        job = VolumeSnapshotContext.new(snapshot_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        sdata = rpc.request('sta-collector', 'get_snapshot', snapshot_id) unless snapshot_id.nil?
        data = rpc.request('sta-collector', 'get_volume', sdata[:origin_volume_id])
        job.stm.state=sdata[:state].to_sym

        vol_path = "#{data[:storage_pool][:export_path]}/#{data[:export_path]}"
        snap_dir = "#{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}"
        unless File.exist?(snap_dir)
          # create a directory to save snapshot
          `mkdir -p #{snap_dir}`
          logger.info("create a directory: #{snap_dir}")
        end
        job.stm.on_create
        snap = `zfs snapshot #{vol_path}@#{sdata[:uuid]}`
        rpc.request('sta-collector', 'update_snapshot', job.to_hash) do |req|
          req.oneshot = true
        end

        job.stm.on_create
        snap_send = `zfs send #{vol_path}@#{sdata[:uuid]} > #{snap_dir}/#{sdata[:uuid]}.zsnap`
        snap_delete = `zfs destroy #{vol_path}@#{sdata[:uuid]}`

        rpc.request('sta-collector', 'update_snapshot', job.to_hash) do |req|
          req.oneshot = true
        end
      end

      def delete_snapshot(snapshot_id)
        job = VolumeSnapshotContext.new(snapshot_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        sdata = rpc.request('sta-collector', 'get_snapshot', snapshot_id) unless snapshot_id.nil?
        data = rpc.request('sta-collector', 'get_volume', sdata[:origin_volume_id])
        job.stm.state=sdata[:state].to_sym
        job.stm.on_delete
        snap_delete = `rm -rf #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}.zsnap`
        rpc.request('sta-collector', 'update_snapshot', job.to_hash) do |req|
          req.oneshot = true
        end
      end

      class VolumeSnapshotContext < OpenStruct

        attr_reader :stm

        def initialize(snapshot_id=nil)
          super({:snapshot_id=>snapshot_id})
          @stm = Statemachine.build {
            trans :registering, :on_create, :creating
            trans :creating, :on_create, :available
            trans :available, :on_delete, :deleting
            trans :deleting, :on_delete, :deleted

            trans :registering, :on_fail, :failed
            trans :creating, :on_fail, :failed
            trans :available, :on_fail, :failed
            trans :deleting, :on_fail, :failed
          }
          @stm.context = self
        end

        def state
          @stm.state
        end

        def to_hash
          @table.dup.merge({:state=>@stm.state})
        end
      end
    end
  end
end
