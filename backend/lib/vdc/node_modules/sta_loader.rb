# -*- coding: utf-8 -*-

module Vdc
  module NodeModules
    class StaLoader < Isono::NodeModules::Base
      include Isono::Logger

      config_section do |c|
      end

      initialize_hook do
        app = myinstance
        rpc = Isono::NodeModules::JobChannel.new(node)
        rpc.register_endpoint("sta-loader.#{node.node_id}", Isono::Rack.build do
                                run Isono::Rack::ObjectMethod.new(app)
                              end)
      end

      terminate_hook do
      end

      def create(volume_id)
        job = VolumeContext.new(volume_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        data = rpc.request('sta-collector', 'get_volume', volume_id)
        sdata = rpc.request('sta-collector', 'get_snapshot', data[:snapshot_id]) unless data[:snapshot_id].nil?
        job.stm.state=data[:state].to_sym
        job.stm.on_create

        vol_path = "#{data[:storage_pool][:export_path]}/#{data[:export_path]}"
        if sdata
          `zfs list #{File.dirname(vol_path)} > /dev/null 2>&1`
          if $?.exitstatus != 0
            # create parent filesystem
            `zfs create -p #{File.dirname(vol_path)}`
          end
          
          v = `zfs receive #{vol_path} < #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}.zsnap`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            job.stm.on_fail
          end

          v = `zfs destroy #{vol_path}@#{sdata[:uuid]}`
          if $?.exitstatus != 0
            logger.info("volume snapshot has not deleted")
            job.stm.on_fail
          end
          vl = `zfs list #{vol_path}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            job.stm.on_fail
          end
        else
          v = `zfs create -p -V #{data[:size]}m #{vol_path}`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            job.stm.on_fail
          end
          vl = `zfs list #{vol_path}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            job.stm.on_fail
          end
        end

        rpc.request('sta-collector', 'update', job.to_hash(data[:export_path])) do |req|
          req.oneshot = true
        end
        logger.info("creating new volume: #{data[:uuid]}")

        job.stm.on_register
        vr = `zfs shareiscsi=on #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
        # if $?.exitstatus != 0
        #   logger.info("failed iscsi target request")
        #   job.stm.on_fail
        # end
        il = `iscsitadm list target -v #{data[:storage_pool][:export_path]}/#{data[:uuid]}`
        if $?.exitstatus != 0
          job.stm.on_fail
        end
        il = il.downcase.split("\n").select {|row| row.strip!}
        opt = {:iqn => il[0].split(": ").last, :lun=>il[6].split(": ").last.to_i}
        # opt = {:iqn => "iqn.1986-03.com.sun:02:787bca42-9639-44e4-f115-f5b06ed31817", :lun => 0}

        rpc.request('sta-collector', 'update', job.to_hash(nil, opt)) do |req|
          req.oneshot = true
        end

        logger.info("registering volume: #{data[:uuid]}")
      end
      
      def delete(volume_id)
        job = VolumeContext.new(volume_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        data = rpc.request('sta-collector', 'get_volume', volume_id)
        job.stm.state=data[:state].to_sym

        # deregisterd iscsi target
        job.stm.on_deregister
        vr = `zfs shareiscsi=off #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        il = `iscsitadm list target #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        unless il.empty?
          logger.debug("iscsi target has not deleted")
          job.stm.on_fail
        end

        rpc.request('sta-collector', 'update', job.to_hash) do |req|
          req.oneshot = true
        end
        return false if job.state == :failed
        logger.info("deregistered iscsi: #{data[:uuid]}")

        # delete volume
        job.stm.on_delete
        v = `zfs destroy #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        vl = `zfs list #{data[:storage_pool][:export_path]}/#{data[:export_path]}`
        unless vl.empty?  
          logger.debug("volume has not deleted")
          job.stm.on_fail
        end

        rpc.request('sta-collector', 'update', job.to_hash) do |req|
          req.oneshot = true
        end
        return false if job.state == :failed
        logger.info("deleted volume: #{data[:uuid]}")
      end

      def create_snapshot(snapshot_id)
        rpc = Isono::NodeModules::RpcChannel.new(node)
        sdata = rpc.request('sta-collector', 'get_snapshot', snapshot_id) unless snapshot_id.nil?
        data = rpc.request('sta-collector', 'get_volume', sdata[:origin_volume_id])
        snap = `zfs snapshot #{data[:storage_pool][:export_path]}/#{data[:export_path]}@#{sdata[:uuid]}`
        snap_send = `zfs send #{data[:storage_pool][:export_path]}/#{data[:export_path]}@#{sdata[:uuid]} > #{data[:storage_pool][:snapshot_base_path]}/#{sdata[:account_id]}/#{sdata[:uuid]}`
        snap_delete = `zfs destroy #{data[:storage_pool][:export_path]}/#{data[:export_path]}@#{sdata[:uuid]}`
      end

      class VolumeContext < OpenStruct

        attr_reader :stm

        def initialize(volume_id=nil)
          super({:volume_id => volume_id,
                  :export_path => nil,
                  :transport_information => nil,
                })
          @stm = Statemachine.build {
            startstate :registering
            superstate :volume_condition do
              trans :registering, :on_create, :creating
              trans :creating, :on_register, :available
              trans :deregistering, :on_deregister, :deleting
              trans :deleting, :on_delete, :deleted

              event :on_fail, :failed
            end

            trans :failed, :on_create, :creating
            trans :failed, :on_register, :available
            trans :failed, :on_fail, :failed
            trans :failed, :on_deregister, :deleting
            trans :failed, :on_delete, :deleted
          }
          @stm.context = self
        end

        def state
          @stm.state
        end

        def to_hash(path=nil, hash=nil)
          @table.dup.merge({:state=>@stm.state, :export_path=>path, :transport_information=>hash})
        end
      end
    end
  end
end
