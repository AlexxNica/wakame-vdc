# -*- coding: utf-8 -*-

module Vdc
  module NodeModules
    class StaLoader < Isono::NodeModules::Base
      include Isono::Logger

      config_section do |c|
      end

      initialize_hook do
        @thread_pool = Isono::ThreadPool.new
        rpc = Isono::NodeModules::RpcChannel.new(node)
        rpc.register_endpoint("sta-loader.#{node.node_id}", Isono::NodeModules::RpcChannel::ObjectDispatcher.new(myinstance))
      end

      terminate_hook do
      end

      def on_create(data)
        data = data.first
        @thread_pool.pass {
          # created new volume
          state = 1
          v = `zfs create -V #{data[:size]}g #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            logger.info("volume already exists")
            state = 4
          end
          vl = `zfs list #{data[:pool_name]}/#{data[:export_path]}`
          if vl.nil? || $?.exitstatus != 0
            logger.info("volume has not be created")
            state = 4
          end
          opts = {:uuid=>data[:uuid], :state => state, :export_path=>data[:export_path]}
          EventMachine.schedule {
            rpc = Isono::NodeModules::RpcChannel.new(node)
            rpc.request('sta-collector', 'status_changed', opts) do |req|
              req.oneshot = true
            end
          }
          logger.info("creating new volume: #{data[:uuid]}")

          # registered iscsi target
          state = 2
          vr = `zfs shareiscsi=on #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            logger.info("failed iscsi target request")
            state = 4
          end
          il = `iscsitadm list target -v #{data[:pool_name]}/#{data[:export_path]}`
          if $?.exitstatus != 0
            state = 4
          end
          il = il.downcase.split("\n").select {|row| row.strip!}
          opts = {:uuid => data[:uuid], :state => state, :transport_information =>{:iqn => il[0].split(": ").last, :lun=>il[6].split(": ").last.to_i}}
          EventMachine.schedule {
            rpc = Isono::NodeModules::RpcChannel.new(node)
            rpc.request('sta-collector', 'status_changed', opts) do |req|
              req.oneshot = true
            end
          }
          logger.info("registering volume: #{data[:uuid]}")
        }
      end

      def on_delete(data)
        data = data.first
        @thread_pool.pass {
          # deregisterd iscsi target
          state = 8
          vr = `zfs shareiscsi=off #{data[:pool_name]}/#{data[:export_path]}`
          il = `iscsitadm list target #{data[:pool_name]}/#{data[:export_path]}`
          unless il.empty?
            logger.debug("iscsi target has not deleted")
            state = 4
          end

          opts ={:uuid=> data[:uuid], :state => state}
          EventMachine.schedule {
            rpc = Isono::NodeModules::RpcChannel.new(node)
            rpc.request('sta-collector', 'status_changed', opts) do |req|
              req.oneshot = true
            end
          }
          return false if state == 4
          logger.info("deregistered iscsi: #{data[:uuid]}")

          # delete volume
          state = 9
          v = `zfs destroy #{data[:pool_name]}/#{data[:export_path]}`
          vl = `zfs list #{data[:pool_name]}/#{data[:export_path]}`
          unless vl.empty?  
            logger.debug ("volume has not deleted")
            state = 4
          end

          opts ={:uuid=> data[:uuid], :state => state}
          EventMachine.schedule {
            rpc = Isono::NodeModules::RpcChannel.new(node)
            rpc.request('sta-collector', 'status_changed', opts) do |req|
              req.oneshot = true
            end
          }
          return false if state == 4
          logger.info("deleted volume: #{data[:uuid]}")
        }
      end
    end
  end
end
