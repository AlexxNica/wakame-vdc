#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require File.expand_path('../../config/path_resolver', __FILE__)

include Isono::Runner::RpcServer
require 'fileutils'


class ServiceNetfilter < Isono::NodeModules::Base
  include Isono::Logger

  initialize_hook do
    myinstance.init_netfilter

    event = Isono::NodeModules::EventChannel.new(node)

    event.subscribe('hva/instance_started', '#') do |args|
      puts "refresh on instance_started: #{args.inspect}"
      myinstance.refresh_netfilter(args)
    end

    event.subscribe('hva/instance_terminated', '#') do |args|
      puts "refresh on instance_terminated: #{args.inspect}"
      myinstance.refresh_netfilter(args)
    end
  end

  def init_netfilter
    EM.defer {
      begin
        init_ebtables
        logger.info("initialize netfilter")
      rescue Exception => e
        p e
      end
    }
  end

  def refresh_netfilter(args)
    inst_id = args[0]
    raise "UnknownInstanceID" if inst_id.nil?

    EM.defer {
      begin
        refresh_ebtables(inst_id)
        logger.info("refreshed netfilter")
      rescue Exception => e
        p e
      end
    }
  end

  def init_ebtables
    cmd = "sudo ebtables --init-table"
    puts cmd
  end

  def refresh_ebtables(inst_id)
    p inst = rpc.request('hva-collector', 'get_instance', inst_id)
    raise "UnknownInstanceID" if inst.nil?

    vif = inst[:instance_nics].first[:vif]
    p ng = rpc.request('hva-collector', 'get_netfilter_groups_of_instance', inst_id)
    rules = ng.map do |g|
      g[:rules].map { |rule| rule[:permission] }
    end
    rules.flatten!

    # group ips
    p ipv4s = rpc.request('hva-collector', 'get_group_instance_ipv4s', inst_id)

    # ebtables
    ebtables = []

    # chains
    chains = []
    protocol_map = {
      'ip4'  => 'ip4',
      'ip6'  => 'ip6',
      'arp'  => 'arp',
      'rarp' => '0x8035'
    }
    commands = [ 'X', 'N' ]

    # make chain names.
    chains << "host_I_#{vif}"
    protocol_map.each { |k,v|
      chains << "I_#{vif}_#{k}"
    }

    ebtables << "-D FORWARD -o #{vif} -j host_I_#{vif}"
    commands.each { |cmd|
      chains.each { |chain|
        ebtables << "-#{cmd} #{chain}"
      }
    }
    p ebtables

    # jump target
    ebtables << "-A FORWARD -o #{vif} -j host_I_#{vif}"
    protocol_map.each { |k,v|
      ebtables << "-A host_I_#{vif} -p #{v} -j I_#{vif}_#{k}"
    }
    ebtables << "-A host_I_#{vif} -p 0x835  -j ACCEPT"
    ebtables << "-A host_I_#{vif}           -j DROP"

    # rules
    self.build_rule(rules).each do |rule|
      case rule[:ip_source]
      when '0.0.0.0'
        ebtables << "-A I_#{vif}_#{rule[:protocol]} --protocol #{rule[:protocol]} --ip-protocol #{rule[:ip_protocol]} --ip-dport #{rule[:ip_dport]} -j ACCEPT"
      else
        ebtables << "-A I_#{vif}_#{rule[:protocol]} --protocol #{rule[:protocol]} --ip-protocol #{rule[:ip_protocol]} --ip-source #{rule[:ip_source]} --ip-dport #{rule[:ip_dport]} -j ACCEPT"
      end
    end

    # group instances
    ipv4s.each do |ipv4|
      ebtables << "-A I_#{vif}_ip4 --protocol ip4 --ip-source #{ipv4} -j ACCEPT"
    end

    ebtables << "-A I_#{vif}_ip4  -p ip4    -j DROP"
    ebtables << "-A I_#{vif}_ip6  -p ip6    -j DROP"
    ebtables << "-A I_#{vif}_arp  -p arp    -j DROP"
    ebtables << "-A I_#{vif}_rarp -p 0x8035 -j DROP"

    ebtables.uniq!
    ebtables.each { |ebtable|
      puts "sudo ebtables #{ebtable}"
    }
  end

  def build_rule(rules = [])
    rule_maps = []

    rules.each do |rule|
      # ex. "tcp:80,80,ip4:0.0.0.0"
      from_pair, ip_dport, source_pair = rule.split(',')

      ip_protocol, ip_sport = from_pair.split(':')
      protocol, ip_source   = source_pair.split(':')

      case ip_protocol
      when 'tcp'
        rule_maps << {
          :protocol => protocol,
          :ip_source => ip_source,
          :ip_protocol => ip_protocol,
          :ip_dport => ip_dport,
        }
      when 'udp'
        rule_maps << {
          :protocol => protocol,
          :ip_source => ip_source,
          :ip_protocol => ip_protocol,
          :ip_dport => ip_dport,
        }
      when 'icmp'
        # through, pending
      end
    end

    rule_maps
  end

  def rpc
    @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
  end

  def event
    @event ||= Isono::NodeModules::EventChannel.new(@node)
  end

end


class KvmHandler < EndpointBuilder
  include Isono::Logger

  job :run_local_store do
    #hva = rpc.delegate('hva-collector')
    inst_id = request.args[0]
    logger.info("Booting #{inst_id}")
    #inst = hva.get_instance(inst_id)

    inst = rpc.request('hva-collector', 'get_instance',  inst_id)

    # setup vm data folder
    FileUtils.mkdir(File.expand_path("#{inst_id}", @node.manifest.config.vm_data_dir))
    # copy image file
    img_src = inst[:image][:source]
    case img_src[:type].to_sym
    when :http
      img_path = File.expand_path("#{inst_id}/#{inst[:uuid]}", @node.manifest.config.vm_data_dir)
      system("curl --silent -o '#{img_path}' #{img_src[:uri]}")
    else
      raise "Unknown image source type: #{img_src[:type]}"
    end

    inst[:disk]
    
    # boot virtual machine
    cmd = sprintf("kvm -m %d -smp %d -name vdc-%s -vnc :%d -drive file=%s -daemonize",
                  inst[:instance_spec][:memory_size],
                  inst[:instance_spec][:cpu_cores],
                  inst_id,
                  inst[:runtime_config][:vnc_port],
                  img_path
                  )
    system(cmd)
    
    rpc.request('hva-collector', 'update_instance',  inst_id, {:state=>:running})
    event.publish('hva/instance_started', :args=>[inst_id])
  end

  job :run_vol_store do
    inst_id = request.args[0]
    vol_id = request.args[1]
    
    inst = rpc.request('hva-collector', 'get_instance', inst_id)
    vol = rpc.request('sta-collector', 'get_volume', vol_id)
    logger.info("Booting #{inst_id}")
    
    # create volume from snapshot
    jobreq.run("sta-loader.#{vol[:storage_pool][:node_id]}", "create", vol_id)
    
    puts "volume created on #{vol[:storage_pool][:node_id]}: #{vol_id}"
    # reload volume info
    vol = rpc.request('sta-collector', 'get_volume', vol_id)

    # attach disk
    lists = `sudo iscsiadm -m discovery -t sendtargets -p #{vol[:storage_pool][:ipaddr]}`
    initiator = `sudo iscsiadm -m node -l -T '#{vol[:transport_information][:iqn]}' --portal '#{vol[:storage_pool][:ipaddr]}:3260'`
    # check under until the dev file is created.
    # /dev/disk/by-path/ip-192.168.1.21:3260-iscsi-iqn.1986-03.com.sun:02:a1024afa-775b-65cf-b5b0-aa17f3476bfc-lun-0
    linux_dev_path = "/dev/disk/by-path/ip-%s-iscsi-%s-lun-%d" % ["#{vol[:storage_pool][:ipaddr]}:3260",
                                                                  vol[:transport_information][:iqn],
                                                                  vol[:transport_information][:lun]]
    tryagain do
      File.exist?(linux_dev_path) ? true : (sleep 1; false)
    end
    
    # run vm
    cmd = sprintf("kvm -m %d -smp %d -name vdc-%s -vnc :%d -drive file=%s -daemonize",
                  inst[:instance_spec][:memory_size],
                  inst[:instance_spec][:cpu_cores],
                  inst_id,
                  inst[:runtime_config][:vnc_port],
                  linux_dev_path
                  )
    if vnic = inst[:instance_nics].first
      cmd += " -net nic,macaddr=#{vnic[:mac_addr].unpack('A2'*6).join(':')} -net tap,ifname=#{vnic[:vif]}"
    end
    puts  cmd
    system(cmd)

    rpc.request('hva-collector', 'update_instance',  inst_id, {:state=>:running})
    event.publish('hva/instance_started', :args=>[inst_id])
  end
  
  job :terminate do
    inst_id = request.args[0]
    hva = rpc.delegate('hva-collector')
    logger.info("Booting #{inst_id}")
    event.publish('hva/instance_terminated', :args=>[inst_id])
  end

  job :attach do
  end

  job :detach do
  end

  def rpc
    @rpc ||= Isono::NodeModules::RpcChannel.new(@node)
  end

  def jobreq
    @jobreq ||= Isono::NodeModules::JobChannel.new(@node)
  end

  def event
    @event ||= Isono::NodeModules::EventChannel.new(@node)
  end


  class TimeoutError < RuntimeError; end
  
  def tryagain(opts={:timeout=>60, :retry=>3}, &blk)
    timedout = false
    curthread = Thread.current

    timersig = EventMachine.add_timer(opts[:timeout]) {
      timedout = true
      if curthread
        curthread.raise(TimeoutError.new("timeout"))
        curthread.pass
      end
    }

    begin
      count = 0
      begin
        break if blk.call
      end while !timedout && ((count += 1) < opts[:retry])
    rescue TimeoutError => e
      raise e
    ensure
      curthread = nil
      EventMachine.cancel_timer(timersig) rescue nil
    end
  end

end

# TODO: delete debug class
class NetfilterHandler < EndpointBuilder
  job :refresh do
    inst_id = request.args[0]
    event.publish('hva/instance_started', :args=>[inst_id])
  end

  def event
    @event ||= Isono::NodeModules::EventChannel.new(@node)
  end
end



manifest = DEFAULT_MANIFEST.dup
manifest.instance_eval do
  node_name 'hva'
  node_instance_id "#{Isono::Util.default_gw_ipaddr}"
  load_module Isono::NodeModules::NodeHeartbeat
  load_module ServiceNetfilter

  config do |c|
    c.vm_data_dir = '/var/lib/vm'
  end

  config_path File.expand_path('config/hva.conf', app_root)
  load_config
end

start(manifest) do
  endpoint "kvm-handle.#{@node.node_id}", KvmHandler
  endpoint "netfilter-handle.#{@node.node_id}", NetfilterHandler
end
